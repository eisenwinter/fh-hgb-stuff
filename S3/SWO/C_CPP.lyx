#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass paper
\begin_preamble
\usepackage[rm,light]{roboto}
\usepackage[T1]{fontenc}
\usepackage[breakable]{tcolorbox}
\usepackage{fontawesome}
\usepackage{microtype}
\usepackage{xcolor}
\definecolor{darkred}{HTML}{9b0909}
\definecolor{mildred}{HTML}{cc0606}
\definecolor{brightred}{HTML}{e52d2d}
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{fit,calc,shadows}
\usetikzlibrary{shapes.callouts}
\usetikzlibrary{positioning}

\newtcolorbox{boxy}{colback=white,colframe=darkred,arc=0mm,boxrule=0.3mm,top=0.2mm,bottom=0.2mm,left=0.2mm}
\newtcolorbox{boxyt}[1]{colback=white,colframe=darkred,arc=0mm,boxrule=0.2mm,top=0.2mm,bottom=0.2mm,title=#1,breakable}
\newtcolorbox{boxys}[1]{colback=white,colframe=darkred,arc=0mm,boxrule=0.2mm,top=0.2mm,bottom=0.2mm,title=#1,sidebyside}

\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}%
   {-3.25ex\@plus -1ex \@minus -.2ex}%
   {1.5ex \@plus .2ex}%
   {\normalfont\normalsize}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language naustrian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 1
\tocdepth 1
\paragraph_separation indent
\paragraph_indentation default
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "language={C++},basicstyle={\ttfamily},keywordstyle={\color{blue}\ttfamily},stringstyle={\color{red}\ttfamily},commentstyle={\color{darkred}\ttfamily},morecomment={[l][\color{magenta}]{\#}},frame=tb,breaklines=true,breakatwhitespace=false,numbers=left,numbersep=5pt,numberstyle={\tiny},xleftmargin={0.5cm},showstringspaces=false,escapechar={^},tabsize=4"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
C&C++ durch Beispiele
\end_layout

\begin_layout SubTitle
\begin_inset Quotes gld
\end_inset

Man kann C und C++ nicht in einer Woche vor der Klausur lernen
\begin_inset Quotes grd
\end_inset

 - H.D.
\end_layout

\begin_layout Author
Jan Maximilian Caspar
\end_layout

\begin_layout Abstract
Eine Einführung in C und C++ anhand von Beispielen.
 Ein Revue passieren lassen eines Semesters SWO3, C, C++ und Spaß rundherum.
 Beispiele mit ein wenig Theorie oben drüber.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
C: ein Schnelldurchlauf
\end_layout

\begin_layout Section
Anatomie eines C Programms
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: einfaches C-Programm}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h> ^
\backslash
tikz[remember picture] 
\backslash
node [] (a) {};^
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(int argc^
\backslash
tikz[remember picture] 
\backslash
node [] (c) {};^, char * argv[]^
\backslash
tikz[remember picture] 
\backslash
node [] (d) {};^){ ^
\backslash
tikz[remember picture] 
\backslash
node [] (b) {};^
\end_layout

\begin_layout Plain Layout

    if(argc != 2){
\end_layout

\begin_layout Plain Layout

        printf("Wrong number of arumgents!
\backslash
n");
\end_layout

\begin_layout Plain Layout

        printf("Usage: %s <args> 
\backslash
n", argv[0]);
\end_layout

\begin_layout Plain Layout

        return -1;^
\backslash
tikz[remember picture] 
\backslash
node [] (h) {};^
\end_layout

\begin_layout Plain Layout

    }else{
\end_layout

\begin_layout Plain Layout

        printf("args = 
\backslash
"%s
\backslash
"
\backslash
n",argv[1]);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return 0;^
\backslash
tikz[remember picture] 
\backslash
node [] (g) {};^
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[remember picture, overlay,every edge/.append style = {
 ->, thick, >=stealth, gray, dashed, line width = 1pt },every node/.append
 style = { align = center, minimum height = 9pt,font = 
\backslash
scriptsize, fill= green!20},text width = 2.5cm ]
\end_layout

\begin_layout Plain Layout

   
\backslash
node [right = 4.7cm of a,text width = 4cm] (A) {Inkludieren der Header-Files};
\end_layout

\begin_layout Plain Layout

   
\backslash
node [right = 1.5cm of b,text width = 4cm] (B) {Eintrittspunkt / Main-Methode};
\end_layout

\begin_layout Plain Layout

   
\backslash
node [above = 0.3cm of c,text width = 3cm] (C) {Argument-Anzahl};
\end_layout

\begin_layout Plain Layout

   
\backslash
node [above = 0.3cm of d,text width = 3cm] (D) {Argument-Array};
\end_layout

\begin_layout Plain Layout

   
\backslash
node [above right = 0.5cm and 9cm of g,text width = 3cm] (G) {Rückgabe/Ende};
\end_layout

\begin_layout Plain Layout

   
\backslash
draw (A.west) edge (a.east);
\end_layout

\begin_layout Plain Layout

   
\backslash
draw (B.west) edge (b.east);
\end_layout

\begin_layout Plain Layout

   
\backslash
draw (C.south) edge (c.north);
\end_layout

\begin_layout Plain Layout

   
\backslash
draw (D.south) edge (d.north);
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

   
\backslash
draw (G.west) edge (g.east);
\end_layout

\begin_layout Plain Layout

   
\backslash
draw (G.west) edge (h.east);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture} 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Args
\end_layout

\begin_layout Standard
Kommandozeilen Argumente wandern an die Main-Funktion über die Variablen
 argc, die Anzahl der übergebenen Argumente, und argv die übergebenen Argumente,
 wobei argv[0] immer den Pfad zur Applikation beinhaltet.
\end_layout

\begin_layout Paragraph
Argumente in Integer konvertieren
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Argument in Integer konvertieren und aufsummieren}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

int main(int argc, char *argv[]){
\end_layout

\begin_layout Plain Layout

    int sum = 0;
\end_layout

\begin_layout Plain Layout

    for(int i = 1; i < argc; i++){
\end_layout

\begin_layout Plain Layout

        int num;
\end_layout

\begin_layout Plain Layout

        sscanf(argv[i], "%d", &num);
\end_layout

\begin_layout Plain Layout

        sum += num;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    printf("sum = %d
\backslash
n",sum);
\end_layout

\begin_layout Plain Layout

    return EXIT_SUCCESS; ^
\backslash
tikz[remember picture] 
\backslash
node [] (exsuc) {};^
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[remember picture, overlay,every edge/.append style = {
 ->, thick, >=stealth, gray, dashed, line width = 1pt },every node/.append
 style = { align = center, minimum height = 9pt,font = 
\backslash
scriptsize, fill= green!20},text width = 2.5cm ]
\end_layout

\begin_layout Plain Layout

   
\backslash
node [right = 1.7cm of exsuc,text width = 2cm] (XS) {Macro für 0};
\end_layout

\begin_layout Plain Layout

   
\backslash
draw (XS.west) edge (exsuc.east);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Speicheranordnung
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Code / Text 
\series bold
ReadOnly
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
 f() | f2() | ...
 | main() | strcopy() 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Data
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
readonly constants | R/W data global vars | BSS uninit data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Heap
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Heap (wächst nach unten)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
shared libs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Shared Library Code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Stack
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[ f() ] [ f2() ][ main ][ret][ p ] [ ln ] (Funktion + lokale Variablen +
 Parameter)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset

Die Größe der Speicherbereich lässt sich mit size ermitteln z.B.
\begin_inset Newline newline
\end_inset


\begin_inset listings
lstparams "language=bash"
inline false
status open

\begin_layout Plain Layout

[jan@starshine 30.09]$ gcc -o segment-sizes segment-sizes.c
\end_layout

\begin_layout Plain Layout

[jan@starshine 30.09]$ size segment-sizes
\end_layout

\begin_layout Plain Layout

   text    data     bss     dec     hex filename
\end_layout

\begin_layout Plain Layout

   1499     592       8    2099     833 segment-sizes
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Ein- und Ausgabe 
\end_layout

\begin_layout Subsection
printf
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},showstringspaces=false,caption={Beispiel: Hello World mit printf}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(int argc, char * argv[]){ 
\end_layout

\begin_layout Plain Layout

    printf("Hello World");
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Box Frameless
position "b"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Paragraph
Darstellungen
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Zeichen
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Format
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
%d
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
int
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
%u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
unsigned int
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
%h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
short int
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
%o / %x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
octal / hex
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
%p
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
pointer
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
%f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
float
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
%e
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Exponent Darstellung
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
%s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
String
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
%c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
char
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "b"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Paragraph

\series bold
Modifikatoren
\end_layout

\begin_layout Description
%6d auf 6 Stellen auffüllen
\end_layout

\begin_layout Description
%-6s Pad-Right 6 Stellen
\end_layout

\begin_layout Description
%ld longint
\end_layout

\begin_layout Description
%*d variale Länge
\end_layout

\begin_layout Description
%62f 6 Stellen insgesamt, 2 Nachkomma daher 3 Vorkommastellen
\end_layout

\begin_layout Description
%% wird zu %
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Ein Beispiel
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: printf mit Formatierung}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(){
\end_layout

\begin_layout Plain Layout

    int i = 24;
\end_layout

\begin_layout Plain Layout

    float x = 2.781;
\end_layout

\begin_layout Plain Layout

    char *s = "addition";
\end_layout

\begin_layout Plain Layout

    printf("%-12s: %03d + %f = %10.2f
\backslash
n",s,i,x,i+x);
\end_layout

\begin_layout Plain Layout

    printf("%0*.*f
\backslash
n", 8,3,12.34);
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Ausgabe
\end_layout

\begin_layout Standard
addition : 024 + 2.781000 = 26.78 
\begin_inset Newline newline
\end_inset

0012.340
\end_layout

\begin_layout Subsection
scanf
\end_layout

\begin_layout Standard
scanf ist das Eingabe-Äquivalent zu printf
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: scanf}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(){
\end_layout

\begin_layout Plain Layout

    char name[20];
\end_layout

\begin_layout Plain Layout

	printf("Name?");
\end_layout

\begin_layout Plain Layout

	scanf("%s", name);
\end_layout

\begin_layout Plain Layout

	printf("Hello %s
\backslash
n", name);
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Strings
\end_layout

\begin_layout Standard
Strings sind in C mit besonderer Vorsicht zu behandeln, sie sind als char-Arrays
 umgesetzt und werden 
\series bold
NULL-terminiert
\series default
.
 Der letzte Character in dem char-Array muss immer der NULL-Terminator 
\series bold

\backslash
0
\series default
 sein, da sonst das Programm nicht aufhört Daten zu lesen bis es den ersten
 NULL-Terminator findet.
 Deshalb haben diese Arrays auch immer die Länge 
\begin_inset Formula $Zeichenkette+1$
\end_inset

, da 
\backslash
0 auch einen 
\begin_inset Quotes gld
\end_inset

Slot
\begin_inset Quotes grd
\end_inset

 im Array braucht.
\end_layout

\begin_layout Subsection
Standarlibrary Funktionen
\end_layout

\begin_layout Description
strlen(s) gibt die Länge des Strings zurück
\end_layout

\begin_layout Description
strcpy(dest,src) kopiert einen String - Achtung füllt ganze Größe auf
\end_layout

\begin_layout Description
strcat(dest,src) konkateniert einen String
\end_layout

\begin_layout Description
strcmp(a,b) vergleicht String a mit String b 
\end_layout

\begin_layout Subsection
string.h Funktionen
\end_layout

\begin_layout Description
strncpy(dest,src,n) kopieren mit Zeichenanzahl vorgegeben
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Arrays
\end_layout

\begin_layout Standard
Arrays sind in C als Pointer realisiert, also ist jedes int[] essentiell
 nichts anderes wie eine Sammlung von Pointern auf Integer.
 Aus diesem Grund ist ein Array niemals Pass-by-value! Die Syntax um ein
 Array anzulegen ist 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type id[<int>];
\end_layout

\end_inset

 als für ein 100 Felder int-Array 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

int values[100];
\end_layout

\end_inset

.
 Mehrdimensionale Arrays in C sind so genannte jagged Arrays, da Arrays
 nur aus Pointern bestehen sind mehrdimensionale Arrays Pointer mit Pointer
 im jeweiligen Index.
 Der Speicherbedarf für 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type a[SIZE1][SIZE2][SIZEU];
\end_layout

\end_inset

 ist stets sizeof(a) * SIZE1 * SIZE2 * SIZEU
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Arrays}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(){
\end_layout

\begin_layout Plain Layout

	// declare array with 10 integer values
\end_layout

\begin_layout Plain Layout

	int values[10]; 
\end_layout

\begin_layout Plain Layout

	// declare and assign a array with 3 integer values
\end_layout

\begin_layout Plain Layout

	int othervalues[3] = { 1, 2, 3 }; 
\end_layout

\begin_layout Plain Layout

	// compiler will generate a array of 4
\end_layout

\begin_layout Plain Layout

	int anothervalues[] = { 1, 2, 3, 4 }; 
\end_layout

\begin_layout Plain Layout

	 // 2x2 array
\end_layout

\begin_layout Plain Layout

	int twodimensional[2][2];
\end_layout

\begin_layout Plain Layout

	// gets 1 from other values array, arrays start with 0
\end_layout

\begin_layout Plain Layout

	int one = othervalues[0]; 
\end_layout

\begin_layout Plain Layout

	//same as above
\end_layout

\begin_layout Plain Layout

	int alsoOne = *(othervalues + 0); 
\end_layout

\begin_layout Plain Layout

	// &othervalues[0] = othervalues + 0 = address of integer on position 0
\end_layout

\begin_layout Plain Layout

	int sizeOfArray = sizeof(othervalues) / sizeof(othervalues[0]);
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Typecast & Integer Promotion
\end_layout

\begin_layout Standard
Über den Cast-Operator lassen sich Variablentypen 
\begin_inset Quotes gld
\end_inset

umcasten
\begin_inset Quotes grd
\end_inset

, die Syntax dafür ist 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(type) expression
\end_layout

\end_inset

, wenn man also nun einen Integer explizit auf einen double casten möchte:
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

double a = (double)b;
\end_layout

\end_inset

 unter der Annahme das b ein Integer ist.
 Der Compiler selbst kann implizit das Casting vornehmen, dies ist über
 die Integer Promotion festgelegt.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: expliziter Typecast}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

main() {
\end_layout

\begin_layout Plain Layout

   int  i = 17;
\end_layout

\begin_layout Plain Layout

   char c = 'c'; /* ascii code value = 99 */
\end_layout

\begin_layout Plain Layout

   int sum;
\end_layout

\begin_layout Plain Layout

   sum = i + c;
\end_layout

\begin_layout Plain Layout

   printf("Sum is %d
\backslash
n", sum );
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Integer Promotion
\end_layout

\begin_layout Standard
Die oben erwähnte implizite Umwandlung lässt sich anhand dieses Beispiels
 gut erkennen.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Integer Promotion}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

main() {
\end_layout

\begin_layout Plain Layout

   int  i = 17;
\end_layout

\begin_layout Plain Layout

   char c = 'c'; /* ascii code value = 99 */
\end_layout

\begin_layout Plain Layout

   int sum;
\end_layout

\begin_layout Plain Layout

   sum = i + c;
\end_layout

\begin_layout Plain Layout

   printf("Sum is %d
\backslash
n", sum );
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Ausgabe
\end_layout

\begin_layout Standard
Die Ausgabe dieser Anwendung ist 
\series bold
Sum is 116
\series default
, da der Character automatisch durch die Integer-Promotion auf 99 umgewandelt
 wird.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Paragraph
Integer Promotion Regeln
\end_layout

\begin_layout Standard
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.2pt"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[every edge/.append style = { <-, thick, >=stealth, gray,
 dashed, line width = 1pt }]
\end_layout

\begin_layout Plain Layout


\backslash
node[draw] at (0,0) (A) {long double};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw, right=of A]  (B) {double};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw,right=of B]  (C) {float};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw,right=of C]  (D) {unsigned long long};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw,right=of D]  (E) {long long};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw,below=of E]  (F) {unsigned long};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw,left=of F]  (G) {long};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw,left=of G]  (H) {unsigned int};
\end_layout

\begin_layout Plain Layout


\backslash
node[draw,left=of H]  (I) {int};
\end_layout

\begin_layout Plain Layout


\backslash
draw (A.east) edge (B.west);
\end_layout

\begin_layout Plain Layout


\backslash
draw (B.east) edge (C.west);
\end_layout

\begin_layout Plain Layout


\backslash
draw (C.east) edge (D.west);
\end_layout

\begin_layout Plain Layout


\backslash
draw (D.east) edge (E.west);
\end_layout

\begin_layout Plain Layout


\backslash
draw (E.south) edge (F.north);
\end_layout

\begin_layout Plain Layout


\backslash
draw (F.west) edge (G.east);
\end_layout

\begin_layout Plain Layout


\backslash
draw (G.west) edge (H.east);
\end_layout

\begin_layout Plain Layout


\backslash
draw (H.west) edge (I.east);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "0.2pt"

\end_inset


\end_layout

\begin_layout Section
Call by value vs Call by reference
\end_layout

\begin_layout Standard

\series bold
Call by reference lässt sich nur über Pointer realisieren in C.
\series default

\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
Call-By-Value (
\series bold
FALSCH
\series default
 in diesem Fall)
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=C,caption={Beispiel: Call-By-Value Swap}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void swap(int x, int y){
\end_layout

\begin_layout Plain Layout

    int temp = x;
\end_layout

\begin_layout Plain Layout

    x = y;
\end_layout

\begin_layout Plain Layout

    y = temp;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(){
\end_layout

\begin_layout Plain Layout

    int x = 10;
\end_layout

\begin_layout Plain Layout

    int y = 20;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    printf("x = %d, y = %d
\backslash
n",x,y);
\end_layout

\begin_layout Plain Layout

    swap(x, y);
\end_layout

\begin_layout Plain Layout

    printf("x = %d, y = %d
\backslash
n",x,y);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Ergebnis
\end_layout

\begin_layout Plain Layout
x = 10, y = 20
\end_layout

\begin_layout Plain Layout
x = 10, y = 20
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
Call-By-Reference
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=C,caption={Beispiel: Call-By-Reference Swap}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void swap(int *x, int *y){
\end_layout

\begin_layout Plain Layout

    int temp = *x;
\end_layout

\begin_layout Plain Layout

    *x = *y;
\end_layout

\begin_layout Plain Layout

    *y = temp;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(){
\end_layout

\begin_layout Plain Layout

    int x = 10;
\end_layout

\begin_layout Plain Layout

    int y = 20;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    printf("x = %d, y = %d
\backslash
n",x,y);
\end_layout

\begin_layout Plain Layout

    swap(&x, &y);
\end_layout

\begin_layout Plain Layout

    printf("x = %d, y = %d
\backslash
n",x,y);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Ergebnis
\end_layout

\begin_layout Plain Layout
x = 10, y = 20
\end_layout

\begin_layout Plain Layout
x = 20, y = 10
\end_layout

\end_inset


\end_layout

\begin_layout Section
static, volatile & extern Variablen
\end_layout

\begin_layout Subsection
static
\end_layout

\begin_layout Standard
erzeugt lokale Variable
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: static Variable}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void f(){
\end_layout

\begin_layout Plain Layout

	static int cnt = 0;
\end_layout

\begin_layout Plain Layout

	cnt++;
\end_layout

\begin_layout Plain Layout

	printf("f() was called %d times
\backslash
n",cnt);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(){
\end_layout

\begin_layout Plain Layout

    for(int i = 0;i < 10; i++){
\end_layout

\begin_layout Plain Layout

        f();
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Ausgabe
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

f() was called 1 times
\end_layout

\begin_layout Plain Layout

f() was called 2 times
\end_layout

\begin_layout Plain Layout

f() was called 3 times
\end_layout

\begin_layout Plain Layout

f() was called 4 times
\end_layout

\begin_layout Plain Layout

f() was called 5 times
\end_layout

\begin_layout Plain Layout

f() was called 6 times
\end_layout

\begin_layout Plain Layout

f() was called 7 times
\end_layout

\begin_layout Plain Layout

f() was called 8 times
\end_layout

\begin_layout Plain Layout

f() was called 9 times
\end_layout

\begin_layout Plain Layout

f() was called 10 times
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
extern
\end_layout

\begin_layout Standard
definiert in .h Files dass die Variable in der Implementierung existiert
 (nur Deklaration).
\end_layout

\begin_layout Subsection
volatile
\end_layout

\begin_layout Standard
markiert die Variable, dass sie von 
\begin_inset Quotes gld
\end_inset

außen
\begin_inset Quotes grd
\end_inset

 also außerhalb des Programms selbst manipuliert wird.
\end_layout

\begin_layout Section
Pointer Arithmetik
\end_layout

\begin_layout Description
++/-– springt immer die Länge des Datentypes
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Pointer Arithmetik}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(){
\end_layout

\begin_layout Plain Layout

	char text[5] = { 'N', 'e', 'i', 'n', '
\backslash
0'} 
\end_layout

\begin_layout Plain Layout

	do {
\end_layout

\begin_layout Plain Layout

		//do something with text
\end_layout

\begin_layout Plain Layout

	} while (*text++ != '
\backslash
0');
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Anmerkung
\end_layout

\begin_layout Standard
In dem obigen Beispiel wird das char-Array Text mit Pointer Arithmetik durchlauf
en (*text++).
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
malloc, calloc & realloc
\end_layout

\begin_layout Description
malloc Reserviert dynamischen Speichern, die genaue Signatur lautet 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

void *malloc(size_t size)
\end_layout

\end_inset

, wobei 
\series bold
size 
\series default
die Größe in Byte ist.
\end_layout

\begin_layout Description
calloc Reserviert dynamischen Speichern aber im Vergleich zu malloc setzt
 calloc den Speicherbereich auf 0, die genaue Signatur lautet 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

void *calloc(size_t nitems, size_t size)
\end_layout

\end_inset

, wobei 
\series bold
nitems
\series default
 die Anzahl an Elemente ist und 
\series bold
size 
\series default
die Größe der Elemente
\end_layout

\begin_layout Description
realloc Ändert die Größe eines Speicherbereichs hinter einem Pointer, die
 genaue Signatur lautet 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

void *realloc(void *ptr, size_t size)
\end_layout

\end_inset

, wobei 
\series bold
ptr 
\series default
der Pointer auf den Speicherbereich ist und 
\series bold
size 
\series default
die neue Größe in Byte ist.
\end_layout

\begin_layout Description
free gibt den Speicher wieder frei, die genaue Signatur lautet 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

void free(void *ptr)
\end_layout

\end_inset

 wobei 
\series bold
ptr 
\series default
ein Zeiger auf den Speicherbereich ist.
\end_layout

\begin_layout Standard
Achtung, malloc, calloc, realloc geben 
\series bold
NULL
\series default
 zurück wenn kein Speicher mehr verfügbar ist
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: malloc}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

int main(){
\end_layout

\begin_layout Plain Layout

	int n = 2; //length of the string
\end_layout

\begin_layout Plain Layout

	char *s = (char*)malloc(sizeof(char)*(n+1)); // +1 --> 
\backslash
0
\end_layout

\begin_layout Plain Layout

	s[2] = 'x';
\end_layout

\begin_layout Plain Layout

	*(s+2) = 'x'; //same as s[2], pointer arith.
\end_layout

\begin_layout Plain Layout

	free(s);
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: malloc, realloc, free}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <stdlib.h> 
\end_layout

\begin_layout Plain Layout

#include <string.h>
\end_layout

\begin_layout Plain Layout

int main(){
\end_layout

\begin_layout Plain Layout

	char *str;
\end_layout

\begin_layout Plain Layout

	str = (char*) malloc(sizeof(char)*4); //reserve the space
\end_layout

\begin_layout Plain Layout

	if(str == NUL) printf("OUT OF MEMORY"); // out of memory
\end_layout

\begin_layout Plain Layout

	strcpy(str, "jan");
\end_layout

\begin_layout Plain Layout

	printf("Hello %s
\backslash
n", str); // Hello jan
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	str = (char*)realloc(str, sizeof(char)*15); //resize space
\end_layout

\begin_layout Plain Layout

	if(str == NULL) printf("OUT OF MEMORY"); // out of memory
\end_layout

\begin_layout Plain Layout

	strcat(str, " maximilian");
\end_layout

\begin_layout Plain Layout

	printf("Hello %s
\backslash
n", str); // Hello jan maximilian
\end_layout

\begin_layout Plain Layout

	free(str); //release memory
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
StandardLib Funktionen
\end_layout

\begin_layout Standard
Häufige genutzte Funktionen aus der C StandardLib:
\end_layout

\begin_layout Description
assert Assertion, um Bedingungen zu prüfen
\end_layout

\begin_layout Description
stdarg.h
\end_layout

\begin_layout Description
div Ganzzahldivision
\end_layout

\begin_layout Description
random/srandom Random und seeded Random / Zufallszahlengenerator
\end_layout

\begin_layout Description
qsort,bsearch Quicksort, Binäre Suche
\end_layout

\begin_layout Description
fopen,fwrite,fclose,fseek,ftell Dateioperationen
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Datentypen
\end_layout

\begin_layout Subsection
Skalare 
\begin_inset Foot
status open

\begin_layout Plain Layout
Quelle: https://www.tutorialspoint.com/cprogramming/c_data_types.htm
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Ganzzahling
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="3">
<features booktabs="true" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Typ
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Größe
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Bereich
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
char
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1 byte
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
-128 bis 127 oder 0 bis 255
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
unsigned char
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1 byte
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0 bis 255
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
signed char
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1 byte
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
-128 bis 127
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
int
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2 or 4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
-32 768 to 32 767 oder -2 147 483 648 to 2 147 483 647
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
unsigned int
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2 or 4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0 bis 65 535 oder 0 bis 4 294 967 295
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
short
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
-32 768 bis 32 767
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
unsigned short
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0 bis 65 535
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
long
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
-2 147 483 648 bis 2 147 483 647
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
unsigned long
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
0 bis 4 294 967 295
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Fließkomma
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features booktabs="true" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Typ
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Größe
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Bereich
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Genauigkeit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
float
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
4 byte
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1.2E-38 bis 3.4E+38
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
6 Dezimalstellen
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
double
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
8 byte
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2.3E-308 bis 1.7E+308
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
15 Dezimalstellen
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
long double
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
10 byte
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
3.4E-4932 bis 1.1E+4932
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
19 Dezimalstellen
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Void
\end_layout

\begin_layout Subsubsection
Funktionsrückgabe
\begin_inset space ~
\end_inset

void 
\end_layout

\begin_layout Standard
Wenn eine Funktion nichts zurück gibt, so ist ihr Rückgabetyp void.
\end_layout

\begin_layout Subsubsection
Funktionsargument
\begin_inset space ~
\end_inset

void
\end_layout

\begin_layout Standard
Wenn eine Funktion keine Argumente nimmt so kann ihr Argumenttyp als void
 definiert werden z.B.
 int DoSomething(void);
\end_layout

\begin_layout Subsubsection
Void-Pointer 
\end_layout

\begin_layout Standard
Ein Pointer auf vom Typ void repräsentiert die Adresse eines beliebigen
 Objektes, aber nicht seinen Typ.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnotesize{
\end_layout

\end_inset

malloc z.B.
 gibt einen void Pointer zurück, welcher dann auf einen beliebigen Typen
 gecastet werden kann.
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Structs
\end_layout

\begin_layout Standard
Structs sind Verbunddatentypen, die Sichtbarkeit von allen 
\begin_inset Quotes gld
\end_inset

Members
\begin_inset Quotes grd
\end_inset

 ist public.
 Structs sind ebenfalls vom 
\begin_inset Quotes gld
\end_inset

Call-By-Value
\begin_inset Quotes grd
\end_inset

 Problem betroffen.
\end_layout

\begin_layout Paragraph
Syntax von Structs
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

struct tag_name
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	type name_1;
\end_layout

\begin_layout Plain Layout

	type name_2;
\end_layout

\begin_layout Plain Layout

	type name_n;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: struct ohne Pointer}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

struct person 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int id;
\end_layout

\begin_layout Plain Layout

	char name[20];
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

int main(){
\end_layout

\begin_layout Plain Layout

	struct person someone = {1, "Someone"};
\end_layout

\begin_layout Plain Layout

	//Person (1) Someone
\end_layout

\begin_layout Plain Layout

	printf("Person: (%d) %s 
\backslash
n", someone.id, someone.name); 
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: struct mit Pointer}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

struct person 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int id;
\end_layout

\begin_layout Plain Layout

	char name[20];
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

int main(){
\end_layout

\begin_layout Plain Layout

	struct person *someone, s;
\end_layout

\begin_layout Plain Layout

	s = {1, "Someone"};
\end_layout

\begin_layout Plain Layout

	someone = &s;
\end_layout

\begin_layout Plain Layout

	//Person (1) Someone
\end_layout

\begin_layout Plain Layout

	printf("Person: (%d) %s 
\backslash
n", someone->id, someone->name);
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Typedef
\end_layout

\begin_layout Standard
Typedef erlaubt 
\begin_inset Quotes gld
\end_inset

Labels
\begin_inset Quotes grd
\end_inset

 für Typen zu vergeben um diese anschließend als Typenamen verwenden zu
 können.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: typedef}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

//typedef + enum
\end_layout

\begin_layout Plain Layout

typedef enum personStatus { Active, Inactive } PersonStatus;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//typedef + struct
\end_layout

\begin_layout Plain Layout

typedef struct person 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int id;
\end_layout

\begin_layout Plain Layout

	char name[20];
\end_layout

\begin_layout Plain Layout

	PersonStatus status;
\end_layout

\begin_layout Plain Layout

} Person; //typedef with tag Person
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(){
\end_layout

\begin_layout Plain Layout

	//no need for struct keyword
\end_layout

\begin_layout Plain Layout

	Person someone = {1, "Someone", Active}; 
\end_layout

\begin_layout Plain Layout

	//Person (1) Someone
\end_layout

\begin_layout Plain Layout

	printf("Person: (%d) %s 
\backslash
n", someone.id, someone.name); 
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Makefiles
\end_layout

\begin_layout Standard
Makefiles werden als Build-Systeme genutzt, ihr Aufbau ist stets:
\begin_inset Newline newline
\end_inset

target : depdencies
\end_layout

\begin_layout Standard
(tab) command args 
\end_layout

\begin_layout Subsection
simples makefile
\end_layout

\begin_layout Standard
main.c benötigt geo.c und weight.c, weight.c benötigt geo.c
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={[gnu]make},caption={Ein einfaches makefile}"
inline false
status open

\begin_layout Plain Layout

CC = gcc # compiler
\end_layout

\begin_layout Plain Layout

CFLAGS = -pedantic -Wall -Wextra -std=c11 -ggdb # compiler flags
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

LD = gcc # linker
\end_layout

\begin_layout Plain Layout

LDFLAGS = -lm # not really needed (links math lib m)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.c.o: # sufix  rule (*.c -> *.o)
\end_layout

\begin_layout Plain Layout

	$(CC) $(CFLAGS) -c $<
\end_layout

\begin_layout Plain Layout

# $< name of first dependecy / prerequisite
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#main application
\end_layout

\begin_layout Plain Layout

geo: main.o geo.o weight.o
\end_layout

\begin_layout Plain Layout

	$(LD) -o $@ main.o geo.o weight.o $(LDFLAGS)
\end_layout

\begin_layout Plain Layout

# @a targetname
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# dependecies
\end_layout

\begin_layout Plain Layout

geo.o: geo.c geo.h # first dep
\end_layout

\begin_layout Plain Layout

weight.o: weight.c weight.h geo.h
\end_layout

\begin_layout Plain Layout

main.o: main.c geo.h weight.h
\end_layout

\end_inset


\end_layout

\begin_layout Part
C++ - wo warst du als der Spaß aufhörte?
\end_layout

\begin_layout Standard
Die C-Standardbibliothek ist vollständig in der C++-Standard-(Klassen-)Bibliothe
k enthalten
\end_layout

\begin_layout Section
Von C auf C++
\begin_inset Foot
status open

\begin_layout Plain Layout
einzelne Beispiele von https://www.cprogramming.com/tutorial/c-vs-c++.html
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der C++ Compiler kann auch C Programme kompilieren (nachdem C ja ein Subset
 von C++ ist) allerdings sind die 
\begin_inset Quotes gld
\end_inset

Constrains
\begin_inset Quotes grd
\end_inset

 viel strenger, hier sind häufige 
\begin_inset Quotes gld
\end_inset

Pitfalls
\begin_inset Quotes grd
\end_inset

 die dem übergang von C auf C++ passieren.
 
\end_layout

\begin_layout Subsection
Impliziertes casten von void*
\end_layout

\begin_layout Standard
In C ist impliziertes casten von void* Stern möglich und auch 
\begin_inset Quotes gld
\end_inset

guter Stil
\begin_inset Quotes grd
\end_inset

.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

int *x = malloc(sizeof(int) * 10);
\end_layout

\end_inset

 ist in C vollkommen in Ordnung, aber wird mit einem C++ Kompiler nicht
 kompilieren.
 Der Grund hierfür ist das malloc 
\series bold
nicht
\series default
 
\series bold
type-safe
\series default
 ist und 
\series bold
void*
\series default
 alles sein kann und zum Zeitpunkt des Kompilierens ist es nicht möglich
 festzustellen was sich hinter dem void* Pointer befindet.
 In C++ ist der preferable Weg für die Allocation mit dem 
\series bold
new Schlüsselwort
\series default
, dieses hat zwei Vorteile gegenüber malloc, es ist
\series bold
 type-safe 
\series default
und es wird sicher gestellt das der 
\series bold
Konstruktor
\series default
 
\series bold
aufgerufen
\series default
 
\series bold
wird
\series default
.
\end_layout

\begin_layout Subsection
Arrays allokieren & löschen (new[] and delete[])
\end_layout

\begin_layout Standard
In C werden sowohl einzelne Typen als auch Arrays gleich angelegt beide
 werden mit malloc reserviert und mit free gelöscht, zum Beispiel
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,caption={Beispiel: C vs CPP: malloc free}"
inline false
status open

\begin_layout Plain Layout

int *x = malloc(sizeof(int));
\end_layout

\begin_layout Plain Layout

int *x_array = malloc(sizeof(int) * 10);
\end_layout

\begin_layout Plain Layout

free(x); 
\end_layout

\begin_layout Plain Layout

free(x_array);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In C++ hingegen ist Arrays allokieren und löschen anders, hierfür gibt es
 die operationen new[] und delete[] welche explizit für Arrays geschaffen
 wurden.
 Dies hat den Grund, dass der delete[] Operator den Konstruktor jedes Elements
 in dem Array aufruft.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: C vs CPP: new[] delete[]}"
inline false
status open

\begin_layout Plain Layout

int *x = new int;
\end_layout

\begin_layout Plain Layout

int *x_array = new int[10];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

delete x;
\end_layout

\begin_layout Plain Layout

delete[] x_array;
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
C in C++
\end_layout

\begin_layout Standard
C lässt sich in C++ ausführen, aber nicht umgekehrt, die Standard C-Libraries
 sind in C++ mit c prefixed, zum Beispiel 
\begin_inset listings
lstparams "caption={Beispiel: C vs CPP: Funktionsreihenfolge}"
inline true
status open

\begin_layout Plain Layout

#include <cstdio>
\end_layout

\end_inset

 für 
\begin_inset listings
lstparams "caption={Beispiel: C vs CPP: Funktionsreihenfolge}"
inline true
status open

\begin_layout Plain Layout

std::printf("%d
\backslash
n", "Hello World!");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
In C++ müssen Funktionen vor ihrem Aufruf deklariert werden
\end_layout

\begin_layout Standard
In C kann die Funktion unterhalb des Aufrufes deklariert werden, dies führt
 in C++ allerdings zu einem Compiler-Fehler
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: C vs CPP: Funktionsreihenfolge}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    foo(); //will compile in c, not in c++
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int foo() 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    printf( "Hello world" );
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
const
\end_layout

\begin_layout Standard
Ander als in C ist const in C++ ist tatsächlich konstant, wobei kostant
 vermutlich die falsche Antwort wäre, viel mehr markiert das 
\begin_inset Quotes gld
\end_inset

const
\begin_inset Quotes grd
\end_inset

 Schlüsselwort Elemente als 
\begin_inset Quotes gld
\end_inset

inmutable
\begin_inset Quotes grd
\end_inset

.
 Es ein 
\begin_inset Quotes gld
\end_inset

compile-time
\begin_inset Quotes grd
\end_inset

 Konstrukt das genutzt wird um die 
\begin_inset Quotes gld
\end_inset

Korrektheit
\begin_inset Quotes grd
\end_inset

 des Codes zu waren, durch das deklarieren einer Variable oder Methode als
 
\begin_inset Quotes gld
\end_inset

const
\begin_inset Quotes grd
\end_inset

 markieren wir das die Daten (auch Kinder oder 
\begin_inset Quotes gld
\end_inset

nested Elements
\begin_inset Quotes grd
\end_inset

) nicht verändert werden.
 Es ist nicht notwendig, aber guter Stil und dokumentiert gleichzeitig die
 Design-Entscheidung, dass es hier zu keiner Änderung kommen soll.
\end_layout

\begin_layout Subsection
Enumerationen
\end_layout

\begin_layout Standard
Im Vergleich zu C lassen sich Enumerationen untereinander nicht mehr einfach
 Vergleichen, sie sind 
\begin_inset Quotes gld
\end_inset

type-safe
\begin_inset Quotes grd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Deklarationen 
\begin_inset Foot
status open

\begin_layout Plain Layout
Quelle des Beispiels http://cs.fit.edu/~mmahoney/cse1502/introcpp.html
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Objekte, Typen und Funktionen können global, lokal oder im Block-Scope deklarier
t werden und sind case-sensistive.
 Alle leeren Initialisierungen von Standardtypen sind stets 
\begin_inset Quotes gld
\end_inset

undefiniert
\begin_inset Quotes grd
\end_inset

, es ist daher empfehlenswert gleich einen Standardwert zu setzen.
 Ich geh jetzt mal davon aus das der Leser mit 
\begin_inset Quotes gld
\end_inset

Block-Scoping
\begin_inset Quotes grd
\end_inset

 vertraut ist und erklär das jetzt nicht extra...
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: mögliche Deklarationen}"
inline false
status open

\begin_layout Plain Layout

// Declaring objects of existing types (global or local)
\end_layout

\begin_layout Plain Layout

int i, j=3;              // Integers, i's initial value is undefined
\end_layout

\begin_layout Plain Layout

double x=3.5, y=j;       // Real numbers, y is 3.0
\end_layout

\begin_layout Plain Layout

bool t=false, u=true;    // Logical e.g.
 if (t && u) {...}
\end_layout

\begin_layout Plain Layout

string s, hi="hello";    // s is initially an empty string, "" in <string>
\end_layout

\begin_layout Plain Layout

char c='a', c2=hi[1];    // Character, c2 is 'e'
\end_layout

\begin_layout Plain Layout

vector<int> a(5);        // Array a[0] through a[4] of int in <vector>
\end_layout

\begin_layout Plain Layout

map<string, int> m;      // Associative array, e.g.
 m["hi"]=5; in <map>
\end_layout

\begin_layout Plain Layout

ifstream in("file.txt"); // Input file e.g.
 while (getline(in, s)) {...} in <fstream>
\end_layout

\begin_layout Plain Layout

ofstream out(s.c_str()); // Output file e.g.
 out << "hello
\backslash
n"; in <fstream>
\end_layout

\begin_layout Plain Layout

const double PI=3.14159; // Not a variable, e.g.
 PI=4; is an error
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Functions (must be global)
\end_layout

\begin_layout Plain Layout

int sum(int a, int b) {return a+b;}  // e.g.
 i=sum(j, 2); sets i=5
\end_layout

\begin_layout Plain Layout

void swap(int& a, int& b) {          // Pass by reference, no return value
\end_layout

\begin_layout Plain Layout

  int tmp=a; a=b; b=tmp;             // e.g.
 swap(i, j); must be variables
\end_layout

\begin_layout Plain Layout

}                                    // Scope of a, b, and tmp ends here,
 implied return;
\end_layout

\begin_layout Plain Layout

void print(const string& s) {cout << s;}  // Pass large objects by const
 reference
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Declaring new types (global or local)
\end_layout

\begin_layout Plain Layout

typedef double Real;     // Real z; declares object z of type double
\end_layout

\begin_layout Plain Layout

struct Complex {         // Complex a; declares a.re, a.im type double
\end_layout

\begin_layout Plain Layout

  Real re, im;           // Data members
\end_layout

\begin_layout Plain Layout

  Complex(double r=0, double i=0) {re=r; im=i;} // Initialization code
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Scope (Gültigkeitsbereich)
\end_layout

\begin_layout Standard
C++ ist genau wie C eine block-orentierte Sprache und in diesen Sprachen
 wird der Gültigkeitsbereich von Namen über die Block-Struktur bestimmt.
 Das Scope selbst lässt sich in einzelne Teilbereiche gliedern.
\begin_inset Foot
status open

\begin_layout Plain Layout
Beispiele aus C++11 standard (ISO/IEC 14882:2011): 3.3 Scope [basic.scope]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Block Scope
\end_layout

\begin_layout Standard
Die Gültigkeit des klassichen 
\begin_inset Quotes gld
\end_inset

Block-Scopes
\begin_inset Quotes grd
\end_inset

 (von daher auch Block-Orentiert) beginnt mit der Deklaration in einem Block
 und endet mit dem Ende des Blocks.
 Das Scope (dt.
 Gültigkeitsbereich) bleibt in den Kinderblöcken prinzipiell erhalten, sollte
 es aber eine neue Deklaration mit gleichen Namen in einem Unterblock geben,
 so wird diese die Übergeordnete überschatten.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Block Scope erklärt}"
inline false
status open

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int a = 0; // scope of the first 'a' begins
\end_layout

\begin_layout Plain Layout

    ++a; // the name 'a' is in scope and refers to the first 'a'
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        int a = 1; // scope of the second 'a' begins
\end_layout

\begin_layout Plain Layout

                   // scope of the first 'a' is interrupted
\end_layout

\begin_layout Plain Layout

        a = 42;    // 'a' is in scope and refers to the second 'a'     
            
\end_layout

\begin_layout Plain Layout

    } // block ends, scope of the second 'a' ends
\end_layout

\begin_layout Plain Layout

      //             scope of the first 'a' resumes
\end_layout

\begin_layout Plain Layout

} // block ends, scope of the first 'a' ends
\end_layout

\begin_layout Plain Layout

int b = a; // Error: name 'a' is not in scope
\end_layout

\end_inset

Das potenzielle Scope von einem Funktionsparameter beginnt wieder an der
 Stelle der Deklaration und endet entweder mit dem letzten Exception-Handler
 eines eines try-catch Blocks oder am Ende der Funktion.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Block Scope Funktionsparameter}"
inline false
status open

\begin_layout Plain Layout

int f(int n = 2)  // scope of 'n' begins
\end_layout

\begin_layout Plain Layout

try // function try block
\end_layout

\begin_layout Plain Layout

{         // the body of the function begins
\end_layout

\begin_layout Plain Layout

   ++n;   // 'n' is in scope and refers to the function parameter
\end_layout

\begin_layout Plain Layout

   {
\end_layout

\begin_layout Plain Layout

      int n = 2; // scope of the local variable 'n' begins
\end_layout

\begin_layout Plain Layout

                 // scope of function parameter 'n' interrupted 
\end_layout

\begin_layout Plain Layout

      ++n; // 'n' refers to the local variable in this block
\end_layout

\begin_layout Plain Layout

    }            // scope of the local variable 'n' ends
\end_layout

\begin_layout Plain Layout

                 // scope of function parameter 'n' resumes
\end_layout

\begin_layout Plain Layout

} catch(...) {
\end_layout

\begin_layout Plain Layout

   ++n; // n is in scope and refers to the function parameter
\end_layout

\begin_layout Plain Layout

   throw;
\end_layout

\begin_layout Plain Layout

} // last exception handler ends, scope of function parameter 'n' ends
\end_layout

\begin_layout Plain Layout

int a = n; // Error: name 'n' is not in scope
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
Exception Handler spannen ein eigenes Block Scope auf
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Block Scope Exceptionhandler}"
inline false
status open

\begin_layout Plain Layout

try {   
\end_layout

\begin_layout Plain Layout

    f();
\end_layout

\begin_layout Plain Layout

} catch(const std::runtime_error& re) { // scope of re begins
\end_layout

\begin_layout Plain Layout

    int n = 1; // scope of n begins
\end_layout

\begin_layout Plain Layout

    std::cout << re.what(); // re is in scope
\end_layout

\begin_layout Plain Layout

} // scope of re ends, scope of n ends
\end_layout

\begin_layout Plain Layout

 catch(std::exception& e) {
\end_layout

\begin_layout Plain Layout

    std::cout << re.what(); // error: re is not in scope
\end_layout

\begin_layout Plain Layout

    ++n; // error: n is not in scope
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Die 
\begin_inset Quotes gld
\end_inset

Range-Declaration
\begin_inset Quotes grd
\end_inset

 in for-Schleifen sind nur im for-Loop selbst gültig.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Block Scope for-loop}"
inline false
status open

\begin_layout Plain Layout

Base* bp = new Derived;
\end_layout

\begin_layout Plain Layout

if(Derived* dp = dynamic_cast<Derived*>(bp))
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    dp->f(); // dp is in scope
\end_layout

\begin_layout Plain Layout

} // scope of dp ends
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

for(int n = 0; // scope of n begins
\end_layout

\begin_layout Plain Layout

    n < 10;    // n is in scope
\end_layout

\begin_layout Plain Layout

    ++n)       // n is in scope
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    std::cout << n << ' '; // n is in scope
\end_layout

\begin_layout Plain Layout

} // scope of n ends
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Namespace Scope
\end_layout

\begin_layout Standard
Vorweg für alle die jetzt keinen Nutzen für Namespaces haben: 
\begin_inset Quotes gld
\end_inset

Namespaces bieten ein Verfahren zur Verhinderung von Namenskonflikte in
 großen Projekten.
\begin_inset Quotes grd
\end_inset

 Namespace Gültigkeiten beginnen stehen mit der Deklaration des Namespace
 Blocks und aggregieren alle 
\begin_inset Quotes gld
\end_inset

genesteden
\begin_inset Quotes grd
\end_inset

, (auch mit using), Namepsaces.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Namespace Scope}"
inline false
status open

\begin_layout Plain Layout

namespace N { // scope of N begins (as a member of global namespace)
\end_layout

\begin_layout Plain Layout

    int i; // scope of i begins
\end_layout

\begin_layout Plain Layout

    int g(int a) { return a; } // scope of g begins
\end_layout

\begin_layout Plain Layout

    int j(); // scope of j begins
\end_layout

\begin_layout Plain Layout

    void q(); // scope of q begins
\end_layout

\begin_layout Plain Layout

    namespace {
\end_layout

\begin_layout Plain Layout

        int x; // scope of x begins
\end_layout

\begin_layout Plain Layout

    } // scope of x does not end
\end_layout

\begin_layout Plain Layout

    inline namespace inl { // scope of inl begins
\end_layout

\begin_layout Plain Layout

      int y; // scope of y begins
\end_layout

\begin_layout Plain Layout

    } // scope of y does not end
\end_layout

\begin_layout Plain Layout

} // scope of i,g,j,q,inl,x,y interrupted
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

namespace {
\end_layout

\begin_layout Plain Layout

    int l=1; // scope of l begins
\end_layout

\begin_layout Plain Layout

} // scope of l does not end (it's a member of unnamed namespace)
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

namespace N { // scope of i,g,j,q,inl,x,y continues
\end_layout

\begin_layout Plain Layout

    int g(char a) {  // overloads N::g(int)
\end_layout

\begin_layout Plain Layout

        return l+a;  // l from unnamed namespace is in scope
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    int i; // error: duplicate definition (i is already in scope)
\end_layout

\begin_layout Plain Layout

    int j(); // OK: repeat function declaration is allowed
\end_layout

\begin_layout Plain Layout

    int j() { // OK: definition of the earlier-declared N::j()
\end_layout

\begin_layout Plain Layout

        return g(i); // calls N::g(int)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    int q(); // error: q is already in scope with different return type
\end_layout

\begin_layout Plain Layout

} // scope of i,g,j,q,inl,x,y interrupted
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    using namespace N; // scope of i,g,j,q,inl,x,y resumes
\end_layout

\begin_layout Plain Layout

    i = 1; // N::i is in scope
\end_layout

\begin_layout Plain Layout

    x = 1; // N::(anonymous)::x is in scope
\end_layout

\begin_layout Plain Layout

    y = 1; // N::inl::y is in scope
\end_layout

\begin_layout Plain Layout

    inl::y = 2; // N::inl is also in scope
\end_layout

\begin_layout Plain Layout

} // scope of i,g,j,q,inl,x,y interrupted
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Class Scope
\end_layout

\begin_layout Standard
Das Klassen-Scope beginnt mit der Deklaration der Klasse und spannt über
 den ganzen 
\begin_inset Quotes gld
\end_inset

Body
\begin_inset Quotes grd
\end_inset

 der Klasse.
 Es umfasst auch alle Unterklassen, Funktionsrümpfe und Exceptionspezifikationen.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Class Scope}"
inline false
status open

\begin_layout Plain Layout

class X {
\end_layout

\begin_layout Plain Layout

    int f(int a = n) { // X::n is in scope inside default parameter
\end_layout

\begin_layout Plain Layout

         return a*n;   // X::n is in scope inside function body
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    int g();
\end_layout

\begin_layout Plain Layout

    int i = n*2;   // X::n is in scope inside initializer
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

//  int x[n];      // Error: n is not in scope in class body
\end_layout

\begin_layout Plain Layout

    static const int n = 1;
\end_layout

\begin_layout Plain Layout

    int x[n];      // OK: n is now in scope in class body
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

int X::g() { return n; } // X::n is in scope in out-of-class member function
 body
\end_layout

\end_inset

Sollte etwas vor der Klassendeklaration bereits den selben Namen haben so
 ist das Programm 
\begin_inset Quotes gld
\end_inset

ill-formed
\begin_inset Quotes grd
\end_inset

, hier ensteht laut C++ Spezifikation 
\begin_inset Quotes gld
\end_inset

Undefined behavior
\begin_inset Quotes grd
\end_inset

 (wieder amoi - so großartig für Spezifikationen); aber zum Glück erkennt
 der Compiler das in diesem Fall.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: ill-formed Class Scope}"
inline false
status open

\begin_layout Plain Layout

typedef int c; // ::c
\end_layout

\begin_layout Plain Layout

enum { i = 1 }; // ::i
\end_layout

\begin_layout Plain Layout

class X {
\end_layout

\begin_layout Plain Layout

    char v[i]; // Error: at this point, i refers to ::i
\end_layout

\begin_layout Plain Layout

               // but there is also X::i
\end_layout

\begin_layout Plain Layout

    int f() {
\end_layout

\begin_layout Plain Layout

         return sizeof(c); // OK: X::c, not ::c is in scope inside a member
 function
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    char c; // X::c
\end_layout

\begin_layout Plain Layout

    enum { i = 2 }; // X::i
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

typedef char* T;
\end_layout

\begin_layout Plain Layout

struct Y {
\end_layout

\begin_layout Plain Layout

    T a; // error: at this point, T refers to ::T
\end_layout

\begin_layout Plain Layout

         // but there is also Y::T
\end_layout

\begin_layout Plain Layout

    typedef long T;
\end_layout

\begin_layout Plain Layout

    T b;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Namen von jeden 
\begin_inset Quotes gld
\end_inset

Class Member
\begin_inset Quotes grd
\end_inset

 können nur in folgenden Kontext genutzt werden
\end_layout

\begin_layout Itemize
In seinem eigenen Scope oder dem einer abgeleiteten Klasse
\end_layout

\begin_layout Itemize
Nach dem .
 Operator auf einen Ausdurck der Klasse oder einer Ableitung
\end_layout

\begin_layout Itemize
Nach dem -> Operator auf den Pointer dieser Klasse oder einer abgeleiteten
 Version
\end_layout

\begin_layout Itemize
Nach dem :: Operator auf die Klasse oder einer Ableitung
\end_layout

\begin_layout Subsection
Enumeration Scope
\end_layout

\begin_layout Standard
Enumerationen gibt es 
\begin_inset Quotes gld
\end_inset

scoped
\begin_inset Quotes grd
\end_inset

 und 
\begin_inset Quotes gld
\end_inset

unscoped
\begin_inset Quotes grd
\end_inset

, am besten wird das einfach Anhand dieses Beispiels illustriert.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Enumeration Scope}"
inline false
status open

\begin_layout Plain Layout

enum e1_t { // unscoped enumeration
\end_layout

\begin_layout Plain Layout

  A,
\end_layout

\begin_layout Plain Layout

  B = A*2
\end_layout

\begin_layout Plain Layout

}; // scope of A and B does not end
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

enum class e2_t { // scoped enumeration
\end_layout

\begin_layout Plain Layout

    SA,
\end_layout

\begin_layout Plain Layout

    SB = SA*2 // SA is in scope
\end_layout

\begin_layout Plain Layout

}; // scope of SA and SB ends
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

e1_t e1 = B; // OK, B is in scope
\end_layout

\begin_layout Plain Layout

// e2_t e2 = SB; // Error: SB is not in scope
\end_layout

\begin_layout Plain Layout

e2_t e2 = e2_t::SB; // OK
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Point of declaration
\end_layout

\begin_layout Standard
Scopes beginnen immer mit dem Point of Declaration, also mit der Deklaration.
 Für Variablen und einfache Deklaration ist der Punkt genau nach der Namensdekla
ration und vor der Initialisierung
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Point of Declaration}"
inline false
status open

\begin_layout Plain Layout

unsigned char x = 32; // scope of the first 'x' begins
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    unsigned char x = x; // scope of the second 'x' begins before the initialize
r (= x)
\end_layout

\begin_layout Plain Layout

                         // this does not initialize the second 'x' with
 the value 32, 
\end_layout

\begin_layout Plain Layout

                         // this initializes the second 'x' with its own,
 indeterminate, value
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

std::function<int(int)> f = [&](int n){return n>1 ? n*f(n-1) : n;};
\end_layout

\begin_layout Plain Layout

           // the name of the function 'f' is in scope within the lambda,
 and can
\end_layout

\begin_layout Plain Layout

           // be correctly captured by reference, giving a recursive function
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Point of Declaration 2}"
inline false
status open

\begin_layout Plain Layout

const int x = 2; // scope of the first 'x' begins
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int x[x] = {}; // scope of the second x begins before the initializer
 (= {})
\end_layout

\begin_layout Plain Layout

                   // but after the declarator (x[x]).
 Within the declarator, the outer
\end_layout

\begin_layout Plain Layout

                   // 'x' is still in scope.
 This declares an array of 2 int.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
String in C++
\end_layout

\begin_layout Standard
Strings sind in C++ nicht wie in C als char-Arrays umgesetzt sondern als
 so genannte 
\begin_inset Quotes gld
\end_inset

Streams
\begin_inset Quotes grd
\end_inset

, an die mit dem << Operator angehängt werden kann.
 Die Umsetzung per-se ist zwar wesentlich komplizierter allerdings auch
 sicherer als die der C-Strings.
 Die Standardlibrary enthält einige nützliche Funktionen zum Thema strings,
 welche in den nachfolgenden Beispielen
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Beispiele von https://www.tutorialspoint.com/cplusplus/cpp_strings.htm und
 http://anaturb.net/C/string_exapm.htm
\end_layout

\end_inset

 illustriert werden.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Strings einfache Beispiele}"
inline false
status open

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

#include <string>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main () {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   string str1 = "Hello";
\end_layout

\begin_layout Plain Layout

   string str2 = "World";
\end_layout

\begin_layout Plain Layout

   string str3;
\end_layout

\begin_layout Plain Layout

   int  len ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   // copy str1 into str3
\end_layout

\begin_layout Plain Layout

   str3 = str1;
\end_layout

\begin_layout Plain Layout

   cout << "str3 : " << str3 << endl;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   // concatenates str1 and str2
\end_layout

\begin_layout Plain Layout

   str3 = str1 + str2;
\end_layout

\begin_layout Plain Layout

   cout << "str1 + str2 : " << str3 << endl;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   // total length of str3 after concatenation
\end_layout

\begin_layout Plain Layout

   len = str3.size();
\end_layout

\begin_layout Plain Layout

   cout << "str3.size() :  " << len << endl;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Ausgabe
\end_layout

\begin_layout Standard
str3 : Hello
\begin_inset Newline newline
\end_inset

str1 + str2 : HelloWorld
\begin_inset Newline newline
\end_inset

str3.size() : 10
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Strings Position}"
inline false
status open

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

#include <string>
\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main () 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    string s = "Nobody is perfect";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Returns s[pos]
\end_layout

\begin_layout Plain Layout

    for ( int pos = 0; pos < s.length(); ++pos )
\end_layout

\begin_layout Plain Layout

    	cout << s.at(pos) << " ";
\end_layout

\begin_layout Plain Layout

    cout << endl;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Ausgabe
\end_layout

\begin_layout Standard
N o b o d y i s p e r f e c t 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: In c-String konvertieren}"
inline false
status open

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

#include <string>
\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main () 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    string str = "Anatoliy";
\end_layout

\begin_layout Plain Layout

    char *ary = new char[str.length()+1];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // strcpy ( ary, str ); that is wrong way
\end_layout

\begin_layout Plain Layout

    strcpy ( ary, str.c_str() ); // that is correct
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    cout << ary << endl;
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Ausgabe
\end_layout

\begin_layout Standard
Anatoliy
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Strings compare}"
inline false
status open

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

#include <string>
\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main () 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    string str1 = "string";
\end_layout

\begin_layout Plain Layout

    string str2 = "String";
\end_layout

\begin_layout Plain Layout

    string str3 = "second string";
\end_layout

\begin_layout Plain Layout

    char ch[]   = "first string";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    cout << "string str1 is : " << str1 << endl;
\end_layout

\begin_layout Plain Layout

    cout << "string str2 is : " << str2 << endl;
\end_layout

\begin_layout Plain Layout

    cout << "char ary ch is : " << ch   << endl;
\end_layout

\begin_layout Plain Layout

    cout << "string str3 is : " << str3 << endl;
\end_layout

\begin_layout Plain Layout

    cout << endl;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // compare str1 and str2
\end_layout

\begin_layout Plain Layout

    cout << "1." << endl;
\end_layout

\begin_layout Plain Layout

    size_t comp = str1.compare(str2);
\end_layout

\begin_layout Plain Layout

    cout << "String str1 is ";
\end_layout

\begin_layout Plain Layout

    ( comp == 0 ) ? cout << "equal" : cout 
\end_layout

\begin_layout Plain Layout

         << "not equal";
\end_layout

\begin_layout Plain Layout

    cout << " to string str2" << endl;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // compare str1 and literal string "string"
\end_layout

\begin_layout Plain Layout

    cout << "2." << endl;
\end_layout

\begin_layout Plain Layout

    comp = str1.compare("string");
\end_layout

\begin_layout Plain Layout

    cout << "String str1 is ";
\end_layout

\begin_layout Plain Layout

    ( comp == 0 ) ? cout << "equal" : cout 
\end_layout

\begin_layout Plain Layout

        << "not equal";
\end_layout

\begin_layout Plain Layout

    cout << " to array of char 
\backslash
"string
\backslash
"" << endl;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // compare str3 start from pos 7 to 5
\end_layout

\begin_layout Plain Layout

    // with str1
\end_layout

\begin_layout Plain Layout

    cout << "3." << endl;
\end_layout

\begin_layout Plain Layout

    comp = str3.compare(str1,7,5);
\end_layout

\begin_layout Plain Layout

    cout << "Part of string str3 is ";
\end_layout

\begin_layout Plain Layout

    ( comp == 0 ) ? cout << "equal" : cout 
\end_layout

\begin_layout Plain Layout

        << "not equal";
\end_layout

\begin_layout Plain Layout

    cout << " to str1" << endl;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // compare str3 start from pos 7
\end_layout

\begin_layout Plain Layout

    // with literal string "string"
\end_layout

\begin_layout Plain Layout

    cout << "4." << endl;
\end_layout

\begin_layout Plain Layout

    comp = str3.compare("string",7);
\end_layout

\begin_layout Plain Layout

    cout << "Part of string str3 is ";
\end_layout

\begin_layout Plain Layout

    ( comp == 0 ) ? cout << "equal" : cout 
\end_layout

\begin_layout Plain Layout

        << "not equal";
\end_layout

\begin_layout Plain Layout

    cout << " to C string 
\backslash
"string
\backslash
"" << endl;
\end_layout

\begin_layout Plain Layout

   return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Ausgabe
\end_layout

\begin_layout Standard
1.
 String str1 is not equal to string str2 
\begin_inset Newline newline
\end_inset

2.
 String str1 is equal to array of char "string" 
\begin_inset Newline newline
\end_inset

3.
 Part of string str3 is equal to str1 
\begin_inset Newline newline
\end_inset

4.
 Part of string str3 is equal to C string "string"
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Strings copy}"
inline false
status open

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

#include <string>
\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main () 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    string str = "First Name: Robert";
\end_layout

\begin_layout Plain Layout

    char fname[255];
\end_layout

\begin_layout Plain Layout

    cout << "str is: " << str << endl;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    int n = str.find(':');
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    str.copy(fname, // copy to array
\end_layout

\begin_layout Plain Layout

            n+1,    // how many char
\end_layout

\begin_layout Plain Layout

            0);     // start position from str
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    // must terminate fname with '
\backslash
0';
\end_layout

\begin_layout Plain Layout

    fname[n+1] = 0;
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    cout << "fname is: " << fname << endl;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Ausgabe
\end_layout

\begin_layout Standard
str is: First Name: Robert 
\begin_inset Newline newline
\end_inset

fname is: First Name:
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Strings find}"
inline false
status open

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

#include <string>
\end_layout

\begin_layout Plain Layout

#include <algorithm>
\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main () 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    string  str("C++ is best language");
\end_layout

\begin_layout Plain Layout

    int pos1, pos2; // size_t or size_type 
\end_layout

\begin_layout Plain Layout

                    // work not correct
\end_layout

\begin_layout Plain Layout

    // search for first string "best" inside of str
\end_layout

\begin_layout Plain Layout

    // default position is 0
\end_layout

\begin_layout Plain Layout

    pos1 = str.find ("best");
\end_layout

\begin_layout Plain Layout

    cout << "Word best is found on position " << pos1+1 
\end_layout

\begin_layout Plain Layout

         << endl;
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    // if pattern is not found - return -1
\end_layout

\begin_layout Plain Layout

    pos2 = str.find ("best",pos1+1);
\end_layout

\begin_layout Plain Layout

    cout << "Word best is found on position " << pos2+1 
\end_layout

\begin_layout Plain Layout

         << endl;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // search for first occurrence of character
\end_layout

\begin_layout Plain Layout

    pos1 = str.find('g');
\end_layout

\begin_layout Plain Layout

    cout << "First character 'g' found on position " 
\end_layout

\begin_layout Plain Layout

         << pos1
\end_layout

\begin_layout Plain Layout

    	 << endl;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // search for first occurrence of string
\end_layout

\begin_layout Plain Layout

    string s = "is";
\end_layout

\begin_layout Plain Layout

    pos1 = str.find (s);
\end_layout

\begin_layout Plain Layout

    cout << "Word 'is' is found on position " << pos1+1 
\end_layout

\begin_layout Plain Layout

         << endl;
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Ausgabe
\end_layout

\begin_layout Standard
Word best is found on position 8 
\begin_inset Newline newline
\end_inset

Word best is found on position 0 
\begin_inset Newline newline
\end_inset

First character 'g' found on position 15 
\begin_inset Newline newline
\end_inset

Word 'is' is found on position 5
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Klassen
\end_layout

\begin_layout Subsection
Struct vs Class
\begin_inset Foot
status open

\begin_layout Plain Layout
Beispiele von https://cs.fit.edu/~mmahoney/cse1502/tutorial/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Subsubsection

\series bold
stuct
\end_layout

\begin_layout Itemize
Daten und Operationen werden zu einer Einheit zusammengefasst
\end_layout

\begin_layout Itemize
Daten und Operationen sind öffentlich zugänglich (sichtbar)
\end_layout

\begin_layout Itemize
Enge Kopplung der Daten mit den Operationen (gleicher Gültigkeitsbereich,
 Daten "automatisch" in Operationen bekannt)
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Subsubsection

\series bold
class
\end_layout

\begin_layout Itemize
Daten und Operationen werden zu einer Einheit zusammengefasst
\end_layout

\begin_layout Itemize
Sichtbarkeit von Daten und Methoden beliebig steuerbar
\end_layout

\end_inset


\end_layout

\begin_layout Description
Hinweis zur Äquivalenz von struct und class:
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

struct X {...}; 
\end_layout

\end_inset

 entspricht 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

class X { public: ...}; 
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

class X {...};
\end_layout

\end_inset

 entspricht 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

struct X { private: ...};
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Person Implmentierung als Struct}"
inline false
status open

\begin_layout Plain Layout

// This program prints my name and age.
  Then it asks for your 
\end_layout

\begin_layout Plain Layout

// name and age and prints it, for example:
\end_layout

\begin_layout Plain Layout

//
\end_layout

\begin_layout Plain Layout

//   Matt is 52 years old.
\end_layout

\begin_layout Plain Layout

//   What is your name? Sam
\end_layout

\begin_layout Plain Layout

//   What is your age? 20
\end_layout

\begin_layout Plain Layout

//   Sam is 20 years old.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

#include <string>
\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// A Person has a name and an age
\end_layout

\begin_layout Plain Layout

struct Person
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  string name;
\end_layout

\begin_layout Plain Layout

  int age;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Print a Person's name and age
\end_layout

\begin_layout Plain Layout

void print(Person p)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  cout << p.name << " is " << p.age << " years old.
\backslash
n";
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Create some people
\end_layout

\begin_layout Plain Layout

  Person me, you;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Print information about me
\end_layout

\begin_layout Plain Layout

  me.name = "Matt";
\end_layout

\begin_layout Plain Layout

  me.age = 52;
\end_layout

\begin_layout Plain Layout

  print(me);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Get information about you and print it
\end_layout

\begin_layout Plain Layout

  cout << "What is your name? ";
\end_layout

\begin_layout Plain Layout

  cin >> you.name;
\end_layout

\begin_layout Plain Layout

  cout << "What is your age? ";
\end_layout

\begin_layout Plain Layout

  cin >> you.age;
\end_layout

\begin_layout Plain Layout

  print(you);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Notes:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

- 'struct Person' defines Person as a new type.
\end_layout

\begin_layout Plain Layout

- 'me' and 'you' are objects of type Person.
\end_layout

\begin_layout Plain Layout

- 'name' and 'age' are members.
\end_layout

\begin_layout Plain Layout

- The members of an object are accessed using the .
 operator
\end_layout

\begin_layout Plain Layout

  using the form 'object.member'.
\end_layout

\begin_layout Plain Layout

- The .
 operator has higher precedence than all other operators.
\end_layout

\begin_layout Plain Layout

  Thus 'me.age + you.age' means '(me.age) + (you.age)'.
\end_layout

\begin_layout Plain Layout

- Objects can be assigned, e.g.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    me = you;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  is equivalent to
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    me.name = you.name;
\end_layout

\begin_layout Plain Layout

    me.age = you.age;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

- Objects cannot be compared, e.g.
 if (me==you) is an error.
\end_layout

\begin_layout Plain Layout

- A struct declaration can be global or local.
  Usual scope
\end_layout

\begin_layout Plain Layout

  rules apply.
  This example is global because it is not declared
\end_layout

\begin_layout Plain Layout

  inside a function.
\end_layout

\begin_layout Plain Layout

- The general form of a struct declaration creating new type T is:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    struct T
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      declarations...;
\end_layout

\begin_layout Plain Layout

    };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  The declaration cannot contain any statements, expressions,
\end_layout

\begin_layout Plain Layout

  or initializatons, e.g.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    struct MyType
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      int a, b;   // OK
\end_layout

\begin_layout Plain Layout

      int x = 0;  // error, can't initialize
\end_layout

\begin_layout Plain Layout

      cout << x;  // error, only declarations are allowed
\end_layout

\begin_layout Plain Layout

    };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

- Don't forget ; after a struct declaration.
\end_layout

\begin_layout Plain Layout

- By convention, user defined type names are Capitalized.
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Person Implmentierung als Class}"
inline false
status open

\begin_layout Plain Layout

// This program prints my name and age.
  Then it asks for your 
\end_layout

\begin_layout Plain Layout

// name and age and prints it, for example:
\end_layout

\begin_layout Plain Layout

//
\end_layout

\begin_layout Plain Layout

//   Matt is 52 years old.
\end_layout

\begin_layout Plain Layout

//   What is your name? Sam
\end_layout

\begin_layout Plain Layout

//   What is your age? 20
\end_layout

\begin_layout Plain Layout

//   Sam is 20 years old.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

#include <string>
\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// A Person can be created with a name and age that can
\end_layout

\begin_layout Plain Layout

// be read from the user or printed.
\end_layout

\begin_layout Plain Layout

class Person
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

private:
\end_layout

\begin_layout Plain Layout

  string name;
\end_layout

\begin_layout Plain Layout

  int age;
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

  Person(string n, int a);  // Constructor
\end_layout

\begin_layout Plain Layout

  Person();     // Another constructor (overloaded)
\end_layout

\begin_layout Plain Layout

  void read();  // Member function to get name and age from user
\end_layout

\begin_layout Plain Layout

  void print()  // Member function (inlined) to print name and age
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    cout << name << " is " << age << " years old.
\backslash
n";
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Code for first constructor
\end_layout

\begin_layout Plain Layout

Person::Person(string n, int a)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  name = n;
\end_layout

\begin_layout Plain Layout

  age = a;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Code for second constructor
\end_layout

\begin_layout Plain Layout

Person::Person()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  name = "";
\end_layout

\begin_layout Plain Layout

  age = 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Code for read
\end_layout

\begin_layout Plain Layout

void Person::read()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  cout << "What is your name? ";
\end_layout

\begin_layout Plain Layout

  cin >> name;
\end_layout

\begin_layout Plain Layout

  cout << "What is your age? ";
\end_layout

\begin_layout Plain Layout

  cin >> age;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// End of definition of class Person
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Test code for class Person
\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  Person me("Matt", 52), you;  // Create 2 objects
\end_layout

\begin_layout Plain Layout

  me.print();
\end_layout

\begin_layout Plain Layout

  you.read();
\end_layout

\begin_layout Plain Layout

  you.print();
\end_layout

\begin_layout Plain Layout

  return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Notes:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

- A class is a type like a struct, except that we hide the
\end_layout

\begin_layout Plain Layout

  implementation (member data) from the rest of the program,
\end_layout

\begin_layout Plain Layout

  and access the data indirectly through a public interface
\end_layout

\begin_layout Plain Layout

  using a set of member functions.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  For example, string is a class.
  We do not know the details 
\end_layout

\begin_layout Plain Layout

  of its implementation (an array of char).
  Instead we only know 
\end_layout

\begin_layout Plain Layout

  how to use strings, e.g.
 input, output, .size(), .substr(), etc.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  In large programs with many variables, grouping the variables
\end_layout

\begin_layout Plain Layout

  into classes helps organize the code, making it easier to maintain.
\end_layout

\begin_layout Plain Layout

  The parts of the program that need to access this data are made
\end_layout

\begin_layout Plain Layout

  into member functions.
  The rest of the program is not allowed
\end_layout

\begin_layout Plain Layout

  to access this data.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

- A class is like a struct but it can also contain member functions
\end_layout

\begin_layout Plain Layout

  (or function prototypes).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

- Member functions have parameters and return types just like
\end_layout

\begin_layout Plain Layout

  ordinary functions, except that they are "attached" to objects.
\end_layout

\begin_layout Plain Layout

  For example:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    me.print()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  calls the member function print() in the object 'me', which is
\end_layout

\begin_layout Plain Layout

  of type 'Person'.
  When print() executes the code 'cout << name'
\end_layout

\begin_layout Plain Layout

  it prints 'me.name'.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

- A class is normally divided into a public and private section.
\end_layout

\begin_layout Plain Layout

  Only the member functions can access the private section, e.g
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    me.print();       // OK, print() is public
\end_layout

\begin_layout Plain Layout

    cout << me.name;  // error, name is private
\end_layout

\begin_layout Plain Layout

    you.age = 10;     // error, age is private
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  The program would still work if everything were public.
  The
\end_layout

\begin_layout Plain Layout

  reason for using private data is so the compiler will enforce
\end_layout

\begin_layout Plain Layout

  the rule that data is only visible to the parts of the program
\end_layout

\begin_layout Plain Layout

  that have the need to know.
  This reduces accidental programming
\end_layout

\begin_layout Plain Layout

  errors.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

- A member function can either be written entirely in the class
\end_layout

\begin_layout Plain Layout

  definition (inlined), or it can be prototyped in the class and
\end_layout

\begin_layout Plain Layout

  the code moved outside.
  It is recommended that only very small
\end_layout

\begin_layout Plain Layout

  (one line) functions be inlined and others be prototyped.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

- When a member function is prototyped, the name of the function
\end_layout

\begin_layout Plain Layout

  has the form class::function, e.g.
 Person::read.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

- The definition must agree with the prototype, just like ordinary
\end_layout

\begin_layout Plain Layout

  functions.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

- A constructor is a special member function that is called
\end_layout

\begin_layout Plain Layout

  automatically when an object is created.
  It is identified
\end_layout

\begin_layout Plain Layout

  by having the same name as the class (Person) and no return type.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

- A constructor, like any function, can be overloaded.
  Overloading
\end_layout

\begin_layout Plain Layout

  means that you can have more than one function with the same name
\end_layout

\begin_layout Plain Layout

  as long as you can distinguish which one you are calling by the
\end_layout

\begin_layout Plain Layout

  argument list.
  For example:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    double max(double a, double b);  // 1
\end_layout

\begin_layout Plain Layout

    int max(int a, int b);           // 2
\end_layout

\begin_layout Plain Layout

    int max(int a, int b, int c);    // 3
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  then max(1.5, 2.0) calls the first version, and max(3, 4, 5)
\end_layout

\begin_layout Plain Layout

  calls the third version.
  Likewise
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Person x;  // calls Person::Person()
\end_layout

\begin_layout Plain Layout

    Person y("Joe", 25);  // calls Person::Person(string, int)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

- It is an error to call a constructor directly, e.g.
 me.Person()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

*/
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Sichtbarkeiten
\begin_inset Foot
status open

\begin_layout Plain Layout
Quelle: Folien H.Dobler
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Für alle Bezeichner (egal ob für Konstanten, Datentypen, Datenkomponenten
 oder Methoden), die in Verbunden (struct), Vereinigungen (union) oder Klassen
 (class) deklariert sind, kann selektiv die Sichtbarkeit geregelt werden
\end_layout

\begin_layout Description
private nur in Methoden derselben Klasse (und in Freunden, s.
 u.) kann auf private Bezeichner (auch anderer Objekte dieser Klasse) zugegriffen
 werden
\end_layout

\begin_layout Description
protected auch in Methoden abgeleiteter Klassen kann auf geschützte Bezeichner
 einer Basisklasse zugegriffen werden
\end_layout

\begin_layout Description
public an allen Stellen (in beliebigen Methoden und Funktionen) kann auf
 öffentliche Bezeichner zugegriffen werden
\end_layout

\begin_layout Standard
Standardmäßig (ohne explizite andere Angabe) gilt:
\end_layout

\begin_layout Itemize
Alle Bezeichner in einem Verbund (struct) oder einer Vereinigung (union)
 sind öffentlich (public) 
\end_layout

\begin_layout Itemize
Alle Bezeichner in einer Klasse (class) sind privat (private)
\end_layout

\begin_layout Standard
Ausnahmen für die "Privatisierung" können über Freunddeklarationen (mittels
 friend) für Funktionen, Methoden und Klassen erreicht werden.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Konstruktoren und Destruktoren
\begin_inset Foot
status open

\begin_layout Plain Layout
Quelle: Folien H.Dobler
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Objekte müssen vor ihrer Verwendung in einen definierten Zustand gebracht
 
\end_layout

\begin_layout Itemize
Konstruktoren werden automatisch aufgerufen, wenn ein Objekt einer Klasse
 erzeugt wird 
\end_layout

\begin_layout Itemize
Destruktoren werden automatisch aufgerufen, wenn ein Objekt einer Klasse
 freigegeben wird
\end_layout

\begin_layout Itemize
Konstruktoren und Destruktoren dürfen keine Rückgabewerte haben
\end_layout

\begin_layout Itemize
Konstruktoren können beliebige Parameter haben und können damit überladen
 werden
\end_layout

\begin_layout Itemize
Destruktoren müssen immer parameterlos sein, daher keine Überladung möglich
\end_layout

\begin_layout Description
statische
\begin_inset space ~
\end_inset

Objekte Konstruktor wird bei Definition automatisch aufgerufen, Destruktor
 wird bei Verlassen des Blocks automatisch aufgerufen
\end_layout

\begin_layout Description
dynamische
\begin_inset space ~
\end_inset

Objekte Konstruktor wird bei Anlegen eines Objekts aufgerufen (von Operator
 new nach Speicherreservierung), Destruktor wird bei Freigeben eines Objekts
 aufgerufen (von Operator delete vor Speicherfreigabe)
\end_layout

\begin_layout Description
Achtung: Wird Destruktor explizit aufgerufen, wird nur Destruktor ausgeführt,
 aber Speicher d.
 Objekts nicht freigegeben, also besser nicht
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Vererbung
\end_layout

\begin_layout Standard
Prinzipiell wie Vererbung funktioniert sollte klar sein, C++ hat da allerdings
 zwei 
\begin_inset Quotes gld
\end_inset

Gusto-Stücke
\begin_inset Quotes grd
\end_inset

 parat.
 Einmal unterstützt C++ mehrfach Vererbung (Diamant Problem!), was einfach
 vermieden werden sollte; es geht, es ist aber so gut wie nie eine gute
 Idee, anderseits Sichtbarkeit der Vererbung.
\begin_inset Foot
status open

\begin_layout Plain Layout
Beispiele zu dem Thema sind von Geeks4Geeks: Harsh Agarwal
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Vererbungs-Syntax}"
inline false
status open

\begin_layout Plain Layout

class subclass_name : access_mode base_class_name
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  //body of subclass
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Simple Vererbung}"
inline false
status open

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

//Base class
\end_layout

\begin_layout Plain Layout

class Parent
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    public:
\end_layout

\begin_layout Plain Layout

      int id_p;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

// Sub class inheriting from Base Class(Parent)
\end_layout

\begin_layout Plain Layout

class Child : public Parent
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    public:
\end_layout

\begin_layout Plain Layout

      int id_c;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

//main function
\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

        Child obj1;
\end_layout

\begin_layout Plain Layout

          
\end_layout

\begin_layout Plain Layout

        // An object of class child has all data members
\end_layout

\begin_layout Plain Layout

        // and member functions of class parent
\end_layout

\begin_layout Plain Layout

        obj1.id_c = 7;
\end_layout

\begin_layout Plain Layout

        obj1.id_p = 91;
\end_layout

\begin_layout Plain Layout

        cout << "Child id is " <<  obj1.id_c << endl;
\end_layout

\begin_layout Plain Layout

        cout << "Parent id is " <<  obj1.id_p << endl;
\end_layout

\begin_layout Plain Layout

         
\end_layout

\begin_layout Plain Layout

        return 0;
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Ausgabe
\end_layout

\begin_layout Standard
Child id is 7
\begin_inset Newline newline
\end_inset

Parent id is 91
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsubsection
Arten der Vererbung
\end_layout

\begin_layout Standard
Hier sind wir jetzt bei einer C++ Besonderheit, es gibt 3 Arten der Vererbung.
 (Siehe access_mode in der Syntax)
\end_layout

\begin_layout Description
public Wenn die abgeleitete Klasse public von der Basisklasse ableitet,
 dann werden alle 
\begin_inset Quotes gld
\end_inset

public member
\begin_inset Quotes grd
\end_inset

 der Basisklasse auch public in der abgeleiteten Klasse, alle 
\begin_inset Quotes gld
\end_inset

protected member
\begin_inset Quotes grd
\end_inset

 der Basisklasse werden protected in der abgeleiteten Klasse und private
 wird nicht vererbt.
\end_layout

\begin_layout Description
protected Wenn wir die abgeleitete Klasse protected von der Basisklasse
 ableiten, dann werden sowohl public als auch protected Member der abgeleiteten
 Klasse protected.
 Private wird nicht vererbt (da-doy! :p)
\end_layout

\begin_layout Description
private Wenn wir abgeleitete Klasse private von der Basisklasse ableiten,
 dann werden sowohl public als auch protected in der Abgeleiteten private.
 Private von oben erbt nicht (Überraschung) 
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Abgeleitet
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Basisklasse
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Public Mode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Private Mode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Protected Mode
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Private
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Protected
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Protected
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Private
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Protected
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Public
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Public
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Private
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Protected
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Überschreiben von Methoden (overriding) 
\begin_inset Foot
status open

\begin_layout Plain Layout
Quelle: Folien H.Dobler
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dynamisch gebundene Methode einer Basisklasse kann in abgeleiteter Klasse
 überschrieben werden 
\end_layout

\begin_layout Description
Invarianz Überschreibende Methode muss identische Parameterliste haben (kann
 aber zu einer konstanten Methode werden)
\end_layout

\begin_layout Description
Kovarianz Nur Ergebnisdatenyp in überschreibender Methode kann auch von
 einer abgeleiteten Klasse sein 
\end_layout

\begin_layout Subsection
Überladen von Methoden (Operator Overloading)
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: PI Operator Overloading}"
inline false
status open

\begin_layout Plain Layout

// This program prints pi to 1000 decimal places using the Spigot
\end_layout

\begin_layout Plain Layout

// algorithm on a new class of high precision fixed point numbers.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

#include <string>
\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// A fixed point number represents number that have the same range
\end_layout

\begin_layout Plain Layout

// as an integer (-2147483648 to 2147483647) but with n decimal
\end_layout

\begin_layout Plain Layout

// places of precision, where the user specifies n.
  n defaults
\end_layout

\begin_layout Plain Layout

// to 1000.
  Supported operations are +=, *=, /= by integers 
\end_layout

\begin_layout Plain Layout

// and <<  (output).
  There are implicit conversions from int to 
\end_layout

\begin_layout Plain Layout

// 1000 decimal place numbers and explicit conversions to any range 
\end_layout

\begin_layout Plain Layout

// of the form Fixed(x, n), where x is the  value and n is the number 
\end_layout

\begin_layout Plain Layout

// of decimal places.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Fixed
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

private:
\end_layout

\begin_layout Plain Layout

  int i;     // integer part, e.g.
 3 in 3.141592
\end_layout

\begin_layout Plain Layout

  string f;  // fractional part as a string of digits, e.g.
 "141592"
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

  Fixed(int x=0, int n=1000); // convert to x with n decimal zeros
\end_layout

\begin_layout Plain Layout

  void operator += (int a) {i+=a;}  // add a
\end_layout

\begin_layout Plain Layout

  void operator *= (int a);   // multiply by a
\end_layout

\begin_layout Plain Layout

  void operator /= (int a);   // divide by a
\end_layout

\begin_layout Plain Layout

  void print(ostream& out);   // print to out as a decimal number
\end_layout

\begin_layout Plain Layout

}; 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Fixed::Fixed(int x, int n)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  i = x;
\end_layout

\begin_layout Plain Layout

  f = string(n, '0');
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void Fixed::operator *= (int a)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  int carry = 0;
\end_layout

\begin_layout Plain Layout

  for (int j=int(f.size())-1; j>=0; --j)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    int d = (f[j]-'0')*a + carry;
\end_layout

\begin_layout Plain Layout

    f[j] = d%10 + '0';
\end_layout

\begin_layout Plain Layout

    carry = d/10;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  i = i*a + carry;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void Fixed::operator /= (int a)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  int carry = i%a;
\end_layout

\begin_layout Plain Layout

  i /= a;
\end_layout

\begin_layout Plain Layout

  for (int j=0; j<int(f.size()); ++j)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    int d = carry*10 + f[j]-'0';
\end_layout

\begin_layout Plain Layout

    carry = d%a;
\end_layout

\begin_layout Plain Layout

    f[j] = d/a + '0';
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void Fixed::print(ostream& out)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  out << i << "." << f;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ostream& operator << (ostream& out, Fixed& f)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  f.print(out);
\end_layout

\begin_layout Plain Layout

  return out;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Compute pi using Spigot algorithm
\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  Fixed pi = 4;
\end_layout

\begin_layout Plain Layout

  for (int i = 3322; i > 0; --i)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    pi *= i;
\end_layout

\begin_layout Plain Layout

    pi /= i * 2 + 1;
\end_layout

\begin_layout Plain Layout

    pi += 2;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  cout << pi << endl;
\end_layout

\begin_layout Plain Layout

  return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Notes:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

- Overloading operators for numeric types allows a more natural notation.
\end_layout

\begin_layout Plain Layout

  For example, you could replace 'Fixed pi = 4' with 'double pi = 4'
\end_layout

\begin_layout Plain Layout

  and the program would still work (but only print 6 digits).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

- An operator is really just a function using a different notation.
  Thus,
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    a += b
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  could be rewritten either as a member function call,
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    a.operator += (b)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  or as a global (nonmember) function,
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    operator += (a, b)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  If += does not already have a meaning, then you can give it one by
\end_layout

\begin_layout Plain Layout

  writing a function called 'operator+=' using one of these two forms
\end_layout

\begin_layout Plain Layout

  (but not both).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  Generally this means you can define an operator as long as either 
\end_layout

\begin_layout Plain Layout

  a or b is a user defined class type, for example:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    void Fixed::operator += (int b);  // as a member
\end_layout

\begin_layout Plain Layout

    void operator += (Fixed a, int b);  // as a global function
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  Because only member functions can access the private data in Fixed,
\end_layout

\begin_layout Plain Layout

  we use this method.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

- You cannot overload operators that already have a meaning, for example,
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    void operator += (int a, int b);  // error, a+=b already defined for
 int
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

- Defining +=, -=, *=, /= does not automatically define +, -, *, /.
\end_layout

\begin_layout Plain Layout

  You need to overload those too.
  Thus if you wanted to write
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    pi = pi + 2;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  You would need to overload + taking Fixed as the left operand and int
\end_layout

\begin_layout Plain Layout

  as the right operand.
  This could be done as a global function without
\end_layout

\begin_layout Plain Layout

  accessing the private data in Fixed:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Fixed operator + (Fixed a, int b)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      a += b;
\end_layout

\begin_layout Plain Layout

      return a;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

- Operators should be overloaded to produce expected behavior.
  Users
\end_layout

\begin_layout Plain Layout

  expect addition to be commutative, but:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    pi = 2 + pi;  // error, no operator + (int, Fixed)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  So you would also need:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Fixed operator + (int a, Fixed b)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      b += a;
\end_layout

\begin_layout Plain Layout

      return b;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

- To reduce the number of overloaded operators, you can use implicit
\end_layout

\begin_layout Plain Layout

  conversion and overload only the highest type.
  For example, given
\end_layout

\begin_layout Plain Layout

  the conversions int -> double -> Fixed, you need only define
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Fixed::Fixed(double);  // constructor for double -> Fixed
\end_layout

\begin_layout Plain Layout

    Fixed operator + (Fixed, Fixed);  // accepts int or double
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  which will handle any mixed mode arithmetic containing at least
\end_layout

\begin_layout Plain Layout

  one Fixed, e.g.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    pi = 2 + pi;  // implicit pi = Fixed(double(2)) + pi;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

- Output can be handled by overloading operator <<.
  The left
\end_layout

\begin_layout Plain Layout

  operand (cout) has type ostream.
  It must be overloaded as a
\end_layout

\begin_layout Plain Layout

  global function because class ostream is part of the standard
\end_layout

\begin_layout Plain Layout

  library and we can't add a member function.
  cout should be
\end_layout

\begin_layout Plain Layout

  passed by reference and returned by reference.
  The general form
\end_layout

\begin_layout Plain Layout

  to print x, which has type T is:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    ostream& operator << (ostream& out, T x)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      // print x to out (not to cout)
\end_layout

\begin_layout Plain Layout

      return out;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  out has to be returned because
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    cout << pi << endl;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  really means
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    (cout << pi) << endl;  // What does endl print to?
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  The return by reference means that (cout << pi) is the original
\end_layout

\begin_layout Plain Layout

  cout and not a temporary copy with the same value.
  You can't copy
\end_layout

\begin_layout Plain Layout

  cout, so it can only be passed or returned by reference.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

- Fixed::print() is needed because operator << is not a member of
\end_layout

\begin_layout Plain Layout

  Fixed and needs to print its private data.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

*/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Smart Pointer
\end_layout

\begin_layout Standard
Der Smartpointer verhält sich ähnlich wie der normale Pointer, allerdings
 löscht er automatisch seinen Speicherbeich wenn er 
\begin_inset Quotes gld
\end_inset

out of scope
\begin_inset Quotes grd
\end_inset

 geht.
 
\begin_inset Foot
status open

\begin_layout Plain Layout
https://www.geeksforgeeks.org/smart-pointers-cpp/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Smartpointer Implementierung}"
inline false
status open

\begin_layout Plain Layout

#include<iostream>
\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

class SmartPtr
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   int *ptr;  // Actual pointer
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

   explicit SmartPtr(int *p = NULL) { ptr = p; } 
\end_layout

\begin_layout Plain Layout

   ~SmartPtr() { delete(ptr); }  
\end_layout

\begin_layout Plain Layout

   // Overloading dereferencing operator
\end_layout

\begin_layout Plain Layout

   int &operator *() {  return *ptr; }
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    SmartPtr ptr(new int());
\end_layout

\begin_layout Plain Layout

    *ptr = 20;
\end_layout

\begin_layout Plain Layout

    cout << *ptr;
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

    // We don't need to call delete ptr: when the object 
\end_layout

\begin_layout Plain Layout

    // ptr goes out of scope, destructor for it is automatically
\end_layout

\begin_layout Plain Layout

    // called and destructor does delete ptr.
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In der C++ STL gibt es fertige Implmentierung 
\end_layout

\begin_layout Subsection
auto_ptr
\end_layout

\begin_layout Standard
Lieftert ein Template für Smartpointer ähnlich dem obigen Beispiel, Teil
 der STL.
 Wurde von unique_pointer in <memory> abgelöst.
 Hat aber folgende Einschränkungen: Bei Zuweisung eines auto_ptr-Objekts
 dest = src; geht Eigentümerschaft an dest über, src ist dann "leer" (nullptr).
 Nicht für Felder von statischen Objekten möglich, denn delete wird im Destrukto
r von auto_ptr immer ohne [] aufgerufen.
\end_layout

\begin_layout Subsection
unique_pointer<T> (statt auto_ptr)
\end_layout

\begin_layout Standard
für Objekte, die nur über einen einzigen Zeiger referenziert werden, mit
 autom.
 Speicherfreigabe bei Blockende
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: unique pointer}"
inline false
status open

\begin_layout Plain Layout

#include<iostream>
\end_layout

\begin_layout Plain Layout

#include<memory>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

class X{
\end_layout

\begin_layout Plain Layout

	public:
\end_layout

\begin_layout Plain Layout

	void m();
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	unique_ptr<X> up1(new X); // X has meth.
 m
\end_layout

\begin_layout Plain Layout

	up1->m();
\end_layout

\begin_layout Plain Layout

	unique_ptr<X> up2;
\end_layout

\begin_layout Plain Layout

	up2 = move(up1); // up2 gains ownership ...
\end_layout

\begin_layout Plain Layout

	up2->m(); // ...
 and up1 is "empty"
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
shared_ptr<T>
\end_layout

\begin_layout Standard
für Objekte, die von mehreren Zeigern (shared_ptr) referenz.
 werden können, mit Referenzenzähler (RZ) u.
 autom.
 Speicherfreigabe wenn RZ = 0 wird
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: shared ptr}"
inline false
status open

\begin_layout Plain Layout

#include<iostream>
\end_layout

\begin_layout Plain Layout

#include<memory>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

class X{
\end_layout

\begin_layout Plain Layout

	public:
\end_layout

\begin_layout Plain Layout

	void m();
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	shared_ptr<X> sp1(new X);
\end_layout

\begin_layout Plain Layout

	sp1->m(); // call X::m()
\end_layout

\begin_layout Plain Layout

	shared_ptr<X> sp2;
\end_layout

\begin_layout Plain Layout

	sp2 = sp1; // now sp1 and sp2 refer.
 ...
\end_layout

\begin_layout Plain Layout

	sp2->m(); // ...
 to the same object
\end_layout

\begin_layout Plain Layout

	sp1 = nullptr; // same as sp1.reset()
\end_layout

\begin_layout Plain Layout

	sp2 = nullptr; // deletes the X object
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Listenknoten freigeben mit shared pointer}"
inline false
status open

\begin_layout Plain Layout

#include<iostream>
\end_layout

\begin_layout Plain Layout

#include<memory>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

class Node { // Node for singly-linked lists: unique_ptr could be used
\end_layout

\begin_layout Plain Layout

	public: // but shared_ptr allows component sharing (see ex.)
\end_layout

\begin_layout Plain Layout

		string val;
\end_layout

\begin_layout Plain Layout

		shared_ptr<Node> next;
\end_layout

\begin_layout Plain Layout

		Node(string val, shared_ptr<Node> next = nullptr) {
\end_layout

\begin_layout Plain Layout

			this->val = val; 
\end_layout

\begin_layout Plain Layout

			this->next = next; // better: init.
 list
\end_layout

\begin_layout Plain Layout

		} // Node
\end_layout

\begin_layout Plain Layout

		virtual ~Node() {
\end_layout

\begin_layout Plain Layout

			cout << "destructing Node with val " << val << endl;
\end_layout

\begin_layout Plain Layout

		} // ~Node
\end_layout

\begin_layout Plain Layout

}; // Node
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(int argc, char *argv[]) {
\end_layout

\begin_layout Plain Layout

	cout << "BEGIN" << endl;
\end_layout

\begin_layout Plain Layout

	shared_ptr<Node> l1(new Node("3"));
\end_layout

\begin_layout Plain Layout

	l1.reset(new Node("2", l1));
\end_layout

\begin_layout Plain Layout

	shared_ptr<Node> l2(new Node("1.2", l1));
\end_layout

\begin_layout Plain Layout

	l1.reset(new Node("1.1", l1));
\end_layout

\begin_layout Plain Layout

	cout << "delete l1:" << endl;
\end_layout

\begin_layout Plain Layout

	l1 = nullptr; // deletes node with "1.1"
\end_layout

\begin_layout Plain Layout

	cout << "END" << endl;
\end_layout

\begin_layout Plain Layout

	return 0; // l2 with all remainig Nodes ...
\end_layout

\begin_layout Plain Layout

} // main // ...
 deleted automatically
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
weak_ptr<T>
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: weak ptr}"
inline false
status open

\begin_layout Plain Layout

#include<iostream>
\end_layout

\begin_layout Plain Layout

#include<memory>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

class X{
\end_layout

\begin_layout Plain Layout

	public:
\end_layout

\begin_layout Plain Layout

	void m();
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	shared_ptr<X> sp(new X);
\end_layout

\begin_layout Plain Layout

	sp->m();
\end_layout

\begin_layout Plain Layout

	weak_ptr<X> wp;
\end_layout

\begin_layout Plain Layout

	wp = sp; // now wp & sp refer to same object
\end_layout

\begin_layout Plain Layout

	wp.lock()->m(); // works
\end_layout

\begin_layout Plain Layout

	sp = nullptr; // deletes the X object
\end_layout

\begin_layout Plain Layout

	wp.lock()->m(); // error: nullptr deref.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
RAII
\end_layout

\begin_layout Standard
Ressourcenbelegung ist Initialisierung, meist abgekürzt durch RAII, für
 englisch resource acquisition is initialization, bezeichnet eine verbreitete
 Programmiertechnik zur Verwaltung von Betriebsmitteln (auch Ressourcen
 genannt).
 Dabei wird die Belegung von Betriebsmitteln an den Konstruktoraufruf einer
 Variablen eines benutzerdefinierten Typs und die Freigabe der Betriebsmittel
 an dessen Destruktoraufruf gebunden.
 Die automatische Freigabe wird beispielsweise durch das Verlassen des Gültigkei
tsbereichs ausgelöst (am Blockende, bei Ausnahmeauslösung, durch Rückgabe
 an den Aufrufer usw.), der implizite Destruktoraufruf der Variablen sorgt
 dann für die Wiederfreigabe der Ressource
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
RTTI
\end_layout

\begin_layout Description
RTTI Run-time Type Identification
\end_layout

\begin_layout Standard
Erlaub das ermitteln eines Types zur Laufzeit.
 RTTI stellt zwei Operatoren zur Verfügung und mithilfe des dynamic_cast
 Operators kann sich in der Vererbeungshirache nach oben gearbeitet werden.
 Der typeid Operator erlaub es den typen eines Objektes festzustellen.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: RTTI}"
inline false
status open

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

#include <typeinfo> // Header for typeid operator
\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Base class
\end_layout

\begin_layout Plain Layout

class MyBase {
\end_layout

\begin_layout Plain Layout

  public:
\end_layout

\begin_layout Plain Layout

    virtual void Print() {
\end_layout

\begin_layout Plain Layout

        cout << "Base class" << endl;
\end_layout

\begin_layout Plain Layout

    };
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Derived class
\end_layout

\begin_layout Plain Layout

class MyDerived : public MyBase {
\end_layout

\begin_layout Plain Layout

  public:
\end_layout

\begin_layout Plain Layout

    void Print() {
\end_layout

\begin_layout Plain Layout

        cout << "Derived class" << endl;
\end_layout

\begin_layout Plain Layout

    };
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // Using typeid on built-in types types for RTTI
\end_layout

\begin_layout Plain Layout

    cout << typeid(100).name() << endl;    
\end_layout

\begin_layout Plain Layout

    cout << typeid(100.1).name() << endl;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Using typeid on custom types for RTTI
\end_layout

\begin_layout Plain Layout

    MyBase* b1 = new MyBase();
\end_layout

\begin_layout Plain Layout

    MyBase* d1 = new MyDerived();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    MyBase* ptr1;
\end_layout

\begin_layout Plain Layout

    ptr1 = d1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    cout << typeid(*b1).name() << endl;
\end_layout

\begin_layout Plain Layout

    cout << typeid(*d1).name() << endl;
\end_layout

\begin_layout Plain Layout

    cout << typeid(*ptr1).name() << endl;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if ( typeid(*ptr1) == typeid(MyDerived) ) {
\end_layout

\begin_layout Plain Layout

    cout << "Ptr has MyDerived object" << endl;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Using dynamic_cast for RTTI
\end_layout

\begin_layout Plain Layout

    MyDerived* ptr2 = dynamic_cast<MyDerived*> ( d1 );
\end_layout

\begin_layout Plain Layout

    if ( ptr2 ) {
\end_layout

\begin_layout Plain Layout

    cout << "Ptr has MyDerived object" << endl;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Ausgabe
\end_layout

\begin_layout Standard
i
\begin_inset Newline newline
\end_inset

d
\begin_inset Newline newline
\end_inset

6MyBase
\begin_inset Newline newline
\end_inset

9MyDerived
\begin_inset Newline newline
\end_inset

9MyDerived
\begin_inset Newline newline
\end_inset

Ptr has MyDerived object
\begin_inset Newline newline
\end_inset

Ptr has MyDerived object
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Rule of Three / Rule of Five
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{boxyt}{
\end_layout

\end_inset

Die Regel der Drei
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...wenn 
\series bold
Copy Constructor
\series default
, 
\series bold
Destructor
\series default
 oder 
\series bold
Copy Assignment Operator
\series default
 als explicit deklariert wird, muss man mit hoher Sicherheit alle Drei als
 explicit deklarieren.
\end_layout

\begin_layout Standard
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard

\series bold
Original
\series default
: The Rule of Three claims that if one of these had to be defined by the
 programmer, it means that the compiler-generated version does not fit the
 needs of the class in one case and it will probably not fit in the other
 cases either.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{boxyt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{boxyt}{
\end_layout

\end_inset

Die Regel der Fünf
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Durch die C++ 11 Erweiterung in Bezug auf die 
\begin_inset Quotes gld
\end_inset

move-semantic
\begin_inset Quotes grd
\end_inset

 wird die Regel der Drei erweitert auf:
\end_layout

\begin_layout Itemize
destructor 
\end_layout

\begin_layout Itemize
copy constructor 
\end_layout

\begin_layout Itemize
move constructor 
\end_layout

\begin_layout Itemize
copy assignment operator 
\end_layout

\begin_layout Itemize
move assignment operator
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{boxyt}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Einführung / Problemstellung
\begin_inset Foot
status open

\begin_layout Plain Layout
Geklaut aus der eigenen Aufarbeitung :p
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Person
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private:
\end_layout

\begin_layout Plain Layout

		string name;
\end_layout

\begin_layout Plain Layout

		int age;
\end_layout

\begin_layout Plain Layout

	public:
\end_layout

\begin_layout Plain Layout

		person(const string& name, int age) : name(name), age(age)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    Person a("Bjarne Stroustrup", 60);
\end_layout

\begin_layout Plain Layout

    Person b(a);   // What happens here?
\end_layout

\begin_layout Plain Layout

    b = a;         // And here?
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Die Grundfrage
\end_layout

\begin_layout Standard
die sich stellt ist, was heißt es eine 
\begin_inset Quotes eld
\end_inset

Kopie
\begin_inset Quotes erd
\end_inset

 eines Objektes anzulegen, die vom Compiler generierte 
\begin_inset Quotes gld
\end_inset

Kopier-Funktionalität
\begin_inset Quotes grd
\end_inset

 kopiert einen Pointer / eine Referenz in dem sie einfach die Speicheradresse
 kopiert, dies führt dazu das die Kopie nur eine Referenz auf das selbe
 Objekt ist - was wir aber in diesem Fall wollen ist eine autarke Kopie
 des Objektes - genauer der Datenkomponenten, das oben angeführte Beispiel
 zeigt 2 
\begin_inset Quotes eld
\end_inset

Kopier-Szenarien
\begin_inset Quotes erd
\end_inset

 einerseits, den Kopier-Konstruktor
\series bold
 Person b(a)
\series default
, dieser hat die Aufgabe eine neues Objekt aus den Daten des bestehenden
 Objektes zu konstruieren andererseits den Kopier-Zuweisungsoperator 
\series bold
b = a
\series default
, dieser ist schwieriger zu realisieren da sich das Objekt auf der linken
 Seite bereits in einem gültigen Zustand befindet.
\end_layout

\begin_layout Paragraph
Nachdem
\end_layout

\begin_layout Standard
wir weder Kopier-Konstruktor noch den Assignment Operator definiert haben
 werden diese implizit vom Compiler gestellt:
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{boxyt}{
\end_layout

\end_inset

Auszug aus dem C++ Standard (Section 12 §1)
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The [...] copy constructor and copy assignment operator, [...] and destructor
 are special member functions.
 [ Note:
\series bold
 The implementation will implicitly declare these member functions for some
 class types when the program does not explicitly declare them
\series default
.
 The implementation will implicitly define them if they are used ...
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{boxyt}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Implizite Definition
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// 1.
 copy ctor
\end_layout

\begin_layout Plain Layout

Person(const person& that) : name(that.name), age(that.age)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// 2.
 copy assignment operator
\end_layout

\begin_layout Plain Layout

Person& operator=(const person& that)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    name = that.name;
\end_layout

\begin_layout Plain Layout

    age = that.age;
\end_layout

\begin_layout Plain Layout

    return *this;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// 3.
 destructor
\end_layout

\begin_layout Plain Layout

~Person()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Die 
\begin_inset Quotes gld
\end_inset

Drei
\begin_inset Quotes grd
\end_inset

 implizit definiert.
\end_layout

\begin_layout Standard
Die Kopie klont unsere Datenkomponenten und legt uns eine neue unabhängige
 Person an, der Destruktor bleibt leer.
 Das ist das 
\begin_inset Quotes gld
\end_inset

Geschenk des Compilers
\begin_inset Quotes grd
\end_inset

 - das passiert wenn man diese 
\begin_inset Quotes gld
\end_inset

Special Member Functions
\begin_inset Quotes grd
\end_inset

 nicht selbst angibt.
 Alles 
\begin_inset Quotes gld
\end_inset

Fun and Games
\begin_inset Quotes grd
\end_inset

 bis zu dem Moment wo eine Datenkomponente nicht ein einfaches 
\begin_inset Quotes gld
\end_inset

Primitive
\begin_inset Quotes grd
\end_inset

 bzw.
 Skalar ist.
 Und wie wir inzwischen wissen: Regel der Drei/Fünf, sobald wir einen anlegen
 müssen - müssen (oder zumindest sollten :P) wir die anderen auch anlegen.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{boxyt}{
\end_layout

\end_inset

Auszug aus dem C++ Standard (Section 12.8)
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Description
§16 The implicitly-defined copy constructor for a non-union class X performs
 a memberwise copy of its subobjects.
 
\end_layout

\begin_layout Description
§30 The implicitly-defined copy assignment operator for a non-union class
 X performs memberwise copy assignment of its subobjects
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{boxyt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Dynamische Datenobjekte
\end_layout

\begin_layout Standard
Hier fängt jetzt die Krux an, nehmen wir das selbe Beispiel - nur anstatt
 eines Strings nehmen wir jetzt, der 
\begin_inset Quotes gld
\end_inset

Einfachheit
\begin_inset Quotes grd
\end_inset

 halber, ein char-Array.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Person
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	char* name;
\end_layout

\begin_layout Plain Layout

	int age;
\end_layout

\begin_layout Plain Layout

	public:
\end_layout

\begin_layout Plain Layout

	// the constructor acquires a resource:
\end_layout

\begin_layout Plain Layout

	// in this case, dynamic memory obtained via new[]
\end_layout

\begin_layout Plain Layout

	Person(const char* the_name, int the_age)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		name = new char[strlen(the_name) + 1];
\end_layout

\begin_layout Plain Layout

		strcpy(name, the_name);
\end_layout

\begin_layout Plain Layout

		age = the_age;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// the destructor must release this resource via delete[]
\end_layout

\begin_layout Plain Layout

	~Person()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		delete[] name;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Problem 
\end_layout

\begin_layout Standard
Hier wird wieder 
\begin_inset Quotes gld
\end_inset

member-wise
\begin_inset Quotes grd
\end_inset

 kopiert, das heißt aber bei dem Char-Array, dass der Skalar-Wert kopiert
 wird und dieser beinhaltet nicht die Daten auf der Adresse sondern die
 Adresse selbst.
 Nun teilt sich die Kopie die entsteht einen Speicherbereich mit dem Original
 und wir bekommen unerwünschtes Verhalten.
\end_layout

\begin_layout Enumerate
Alle Änderungen des Namens von Person a wird ist automatisch auch in dem
 kopierten Objekt Person b.
\end_layout

\begin_layout Enumerate
Sobald b zerstört wird, ist der Pointer in a ein ungültiger Pointer
\end_layout

\begin_layout Enumerate
Einen ungültigen Pointer erneut löschen erzeugt undefinierbares Verhalten.
\end_layout

\begin_layout Enumerate
Memory Leaks über Zeit 
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection

\lang ngerman
Explizite
\lang naustrian
 Definition
\end_layout

\begin_layout Standard
Nachdem wir nun das Problem der implicit Kopie (
\begin_inset Quotes gld
\end_inset

member-wise cloning
\begin_inset Quotes grd
\end_inset

) kennen und eben dieses Verhalten nicht wollen müssen wir einen Kopier-Konstruk
tor und einen 
\begin_inset Quotes gld
\end_inset

Copy-Assignment-Operator
\begin_inset Quotes grd
\end_inset

 bzw Kopier-Zuweisungsoperator selbst anlegen um dieses Problem zu beheben.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// 1.
 copy constructor
\end_layout

\begin_layout Plain Layout

Person(const person& that)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	name = new char[strlen(that.name) + 1];
\end_layout

\begin_layout Plain Layout

	strcpy(name, that.name);
\end_layout

\begin_layout Plain Layout

	age = that.age;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// 2.
 copy assignment operator
\end_layout

\begin_layout Plain Layout

Person& operator=(const person& that)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	if (this != &that)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		delete[] name;
\end_layout

\begin_layout Plain Layout

		// This is a dangerous point in the flow of execution!
\end_layout

\begin_layout Plain Layout

		// We have temporarily invalidated the class invariants,
\end_layout

\begin_layout Plain Layout

		// and the next statement might throw an exception,
\end_layout

\begin_layout Plain Layout

		// leaving the object in an invalid state 
\end_layout

\begin_layout Plain Layout

		name = new char[strlen(that.name) + 1];
\end_layout

\begin_layout Plain Layout

		strcpy(name, that.name);
\end_layout

\begin_layout Plain Layout

		age = that.age;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return *this;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Achtung
\end_layout

\begin_layout Standard
Hier wird nun auch der oben erwähnte Komplexitätsunterschied zwischen Kopier-Kon
struktor und Kopier-Zuweisungsoperator sichtbar.
 Wir müssen im Kopier-Zuweisungsoperator prüfen ob es sich nicht um das
 selbe Objekt handelt, da wir sonst das Quell-Array zerstören würden und
 nicht wieder herstellen könnten.
 Außerdem müssen wir das Char-Array löschen um keine Memory Leaks zu produzieren
, da dieses, anders als beim Kopier-Konstrukt bereits existiert.
 Was an dem oberen Beispiel immer noch ein Problem darstellen kann, ist
 wenn der Speicher zum erneuten Reservieren des Arrays nicht mehr ausreicht,
 hier kann es durch das fangen der geworfenen Exception passieren, dass
 das Objekt in einem ungültigen Zustand hinterlassen wird.
\end_layout

\begin_layout Subsubsection
Kopierschutz
\end_layout

\begin_layout Standard
Wenn man nun nicht möchte, dass das Objekt kopiert werden kann so setzt
 man den Kopier-Zuweisungsoperator und den Kopierkonstruktor einfach private
 ohne Implmentierung:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

private:
\end_layout

\begin_layout Plain Layout

	Person(const person& that);
\end_layout

\begin_layout Plain Layout

	Person& operator=(const person& that);
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
C++ 11 aufwärts
\end_layout

\begin_layout Standard
unterstütz eine eigene Semantik um diesen Kopierschutz umzusetzen: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

	Person(const person& that) = delete
\end_layout

\begin_layout Plain Layout

	Person& operator=(const person& that) = delete
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Erweiterung 
\begin_inset Quotes gld
\end_inset

move-semantics
\begin_inset Quotes grd
\end_inset


\end_layout

\begin_layout Standard
Ab C++11 sind die so genannten 
\begin_inset Quotes gld
\end_inset

move-semantics
\begin_inset Quotes grd
\end_inset

 dazu gekommen, diese ermöglichen es einem anderen Objekt einem anderen
 Daten zu 
\begin_inset Quotes gld
\end_inset

stehlen
\begin_inset Quotes grd
\end_inset

.
 Zusammen mit den Drei vorher genannten 
\begin_inset Quotes gld
\end_inset

Special Member Functions
\begin_inset Quotes grd
\end_inset

 bilden die zwei Weiteren, Move-Konstruktor und Move-Zuweisungsoperator,
 die 
\series bold
Regel der Fünf
\series default
.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// 1.
 Move Ctor
\end_layout

\begin_layout Plain Layout

Person&(Person&& that)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	//if its unsure that that.name is initialized
\end_layout

\begin_layout Plain Layout

	//also add a check for nullptr
\end_layout

\begin_layout Plain Layout

	name = that.name;
\end_layout

\begin_layout Plain Layout

	age = that.age;
\end_layout

\begin_layout Plain Layout

	//'stolen' data
\end_layout

\begin_layout Plain Layout

	that.name = nullptr;
\end_layout

\begin_layout Plain Layout

	//'stolen' scalar value gets its 'default'
\end_layout

\begin_layout Plain Layout

	that.age = 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// 2.
 Move-Assignment Operator for Person
\end_layout

\begin_layout Plain Layout

Person& operator=(Person&& that)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	if (this != &that)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		delete[] name;
\end_layout

\begin_layout Plain Layout

		name = that.name;
\end_layout

\begin_layout Plain Layout

		age = that.age;
\end_layout

\begin_layout Plain Layout

		// we have 'stolen' the data
\end_layout

\begin_layout Plain Layout

		that.name = nullptr;
\end_layout

\begin_layout Plain Layout

		that.age = 0;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return *this;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Schlüsselwörter Index
\end_layout

\begin_layout Standard
Für eine Schnellübersicht siehe 
\begin_inset CommandInset ref
LatexCommand vref
reference "part:Anhang:-Schnellerklärung-aller"

\end_inset


\end_layout

\begin_layout Subsection
Übernommen von C
\end_layout

\begin_layout Standard

\series bold
auto const double float int short struct unsigned break continue else for
 long signed switch void case default enum goto register sizeof typedef
 volatile char do extern if return static union while
\end_layout

\begin_layout Subsection
Neu in C++
\end_layout

\begin_layout Standard

\series bold
asm dynamic_cast namespace reinterpret_cast try bool explicit new static_cast
 typeid catch false operator template typename class friend private this
 using const_cast inline public throw virtual delete mutable protected true
 wchar_t
\end_layout

\begin_layout Subsection
Ab C++11
\end_layout

\begin_layout Standard

\series bold
and bitand compl not_eq or_eq xor_eq and_eq bitor not or xor
\end_layout

\begin_layout Subsection
Vordefinierte Namen
\end_layout

\begin_layout Standard

\series bold
cin endl INT_MIN iomanip main npos std cout include INT_MAX iostream MAX_RAND
 NULL string
\end_layout

\begin_layout Section
Implmentierungen
\end_layout

\begin_layout Subsection
Quickselect (C)
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Quickselect C Implmentierung}"
inline false
status open

\begin_layout Plain Layout

/* * * * * * * * * * *
\end_layout

\begin_layout Plain Layout

 2017, Caspar Jan 	 
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

* * * * * * * * * * */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * @brief helper function to swap elements in array
\end_layout

\begin_layout Plain Layout

 * 
\end_layout

\begin_layout Plain Layout

 * @param l left part for swap
\end_layout

\begin_layout Plain Layout

 * @param r right part for swap
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

void swap(int *l, int *r){
\end_layout

\begin_layout Plain Layout

	int temp = *l;
\end_layout

\begin_layout Plain Layout

	*l = *r;
\end_layout

\begin_layout Plain Layout

	*r = temp;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * @brief quicksort rec
\end_layout

\begin_layout Plain Layout

 * 
\end_layout

\begin_layout Plain Layout

 * @param a array
\end_layout

\begin_layout Plain Layout

 * @param left left-side
\end_layout

\begin_layout Plain Layout

 * @param right right-side
\end_layout

\begin_layout Plain Layout

 * @param i i-th element to be found
\end_layout

\begin_layout Plain Layout

 * @return int i-th largest element
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

int quicks(int a[], int left, int right, int i){
\end_layout

\begin_layout Plain Layout

	int px = a[right];
\end_layout

\begin_layout Plain Layout

	int p = left;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	for(int x = left; x < right; x++){
\end_layout

\begin_layout Plain Layout

		if(a[x] > px){
\end_layout

\begin_layout Plain Layout

			swap(&a[p],&a[x]);
\end_layout

\begin_layout Plain Layout

			p++;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	swap(&a[p], &a[right]);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	if(p == (i-1)){
\end_layout

\begin_layout Plain Layout

		return a[p];
\end_layout

\begin_layout Plain Layout

	}else if((i-1) < p){ // has to be left
\end_layout

\begin_layout Plain Layout

		return quicks(a,left,p-1,i);
\end_layout

\begin_layout Plain Layout

	}else{ //has to be right
\end_layout

\begin_layout Plain Layout

		return quicks(a,p+1,right,i);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * @brief retuns the ith largest object from a array
\end_layout

\begin_layout Plain Layout

 * based on a quickselect
\end_layout

\begin_layout Plain Layout

 * @param a array 
\end_layout

\begin_layout Plain Layout

 * @param n size of array
\end_layout

\begin_layout Plain Layout

 * @param i i-th element to be returned
\end_layout

\begin_layout Plain Layout

 * @return int i-th element from array
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

int quickselect(int a[], int n, int i){
\end_layout

\begin_layout Plain Layout

	int l = quicks(a,0,n-1,i);
\end_layout

\begin_layout Plain Layout

	return l;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Binary Search
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Binary Search}"
inline false
status open

\begin_layout Plain Layout

int binary_search(int arr[], int start, int end, const int key)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // Termination condition: start index greater than end index
\end_layout

\begin_layout Plain Layout

    if(start > end)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        return -1;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Find the middle element of the array and use that for splitting
\end_layout

\begin_layout Plain Layout

    // the array into two pieces.
\end_layout

\begin_layout Plain Layout

    const int middle = start + ((end - start) / 2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if(arr[middle] == key)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        return middle;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else if(arr[middle] > key)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        return binary_search(arr, start, middle - 1, key);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return binary_search(arr, middle + 1, end, key);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Knapsack
\begin_inset Foot
status open

\begin_layout Plain Layout
https://www.geeksforgeeks.org/knapsack-problem/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Knappsack}"
inline false
status open

\begin_layout Plain Layout

/* A Naive recursive implementation of 0-1 Knapsack problem */
\end_layout

\begin_layout Plain Layout

#include<stdio.h>
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

// A utility function that returns maximum of two integers
\end_layout

\begin_layout Plain Layout

int max(int a, int b) { return (a > b)? a : b; }
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

// Returns the maximum value that can be put in a knapsack of capacity W
\end_layout

\begin_layout Plain Layout

int knapSack(int W, int wt[], int val[], int n)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   // Base Case
\end_layout

\begin_layout Plain Layout

   if (n == 0 || W == 0)
\end_layout

\begin_layout Plain Layout

       return 0;
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

   // If weight of the nth item is more than Knapsack capacity W, then
\end_layout

\begin_layout Plain Layout

   // this item cannot be included in the optimal solution
\end_layout

\begin_layout Plain Layout

   if (wt[n-1] > W)
\end_layout

\begin_layout Plain Layout

       return knapSack(W, wt, val, n-1);
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

   // Return the maximum of two cases: 
\end_layout

\begin_layout Plain Layout

   // (1) nth item included 
\end_layout

\begin_layout Plain Layout

   // (2) not included
\end_layout

\begin_layout Plain Layout

   else return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1),
\end_layout

\begin_layout Plain Layout

                    knapSack(W, wt, val, n-1)
\end_layout

\begin_layout Plain Layout

                  );
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

// Driver program to test above function
\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int val[] = {60, 100, 120};
\end_layout

\begin_layout Plain Layout

    int wt[] = {10, 20, 30};
\end_layout

\begin_layout Plain Layout

    int  W = 50;
\end_layout

\begin_layout Plain Layout

    int n = sizeof(val)/sizeof(val[0]);
\end_layout

\begin_layout Plain Layout

    printf("%d", knapSack(W, wt, val, n));
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Matrix transponieren
\begin_inset Foot
status open

\begin_layout Plain Layout
https://www.programiz.com/cpp-programming/examples/matrix-transpose
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Beispiel: Matrix transponieren}"
inline false
status open

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int a[10][10], trans[10][10], r, c, i, j;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    cout << "Enter rows and columns of matrix: ";
\end_layout

\begin_layout Plain Layout

    cin >> r >> c;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Storing element of matrix entered by user in array a[][].
\end_layout

\begin_layout Plain Layout

    cout << endl << "Enter elements of matrix: " << endl;
\end_layout

\begin_layout Plain Layout

    for(i = 0; i < r; ++i)
\end_layout

\begin_layout Plain Layout

    for(j = 0; j < c; ++j)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        cout << "Enter elements a" << i + 1 << j + 1 << ": ";
\end_layout

\begin_layout Plain Layout

        cin >> a[i][j];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Displaying the matrix a[][]
\end_layout

\begin_layout Plain Layout

    cout << endl << "Entered Matrix: " << endl;
\end_layout

\begin_layout Plain Layout

    for(i = 0; i < r; ++i)
\end_layout

\begin_layout Plain Layout

        for(j = 0; j < c; ++j)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            cout << " " << a[i][j];
\end_layout

\begin_layout Plain Layout

            if(j == c - 1)
\end_layout

\begin_layout Plain Layout

                cout << endl << endl;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Finding transpose of matrix a[][] and storing it in array trans[][].
\end_layout

\begin_layout Plain Layout

    for(i = 0; i < r; ++i)
\end_layout

\begin_layout Plain Layout

        for(j = 0; j < c; ++j)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            trans[j][i]=a[i][j];
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Displaying the transpose,i.e, Displaying array trans[][].
\end_layout

\begin_layout Plain Layout

    cout << endl << "Transpose of Matrix: " << endl;
\end_layout

\begin_layout Plain Layout

    for(i = 0; i < c; ++i)
\end_layout

\begin_layout Plain Layout

        for(j = 0; j < r; ++j)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            cout << " " << trans[i][j];
\end_layout

\begin_layout Plain Layout

            if(j == r - 1)
\end_layout

\begin_layout Plain Layout

                cout << endl << endl;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Schnellerklärung aller C++ Schlüsselwörter
\begin_inset CommandInset label
LatexCommand label
name "part:Anhang:-Schnellerklärung-aller"

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.bogotobogo.com/cplusplus/cplusplus_keywords.php
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "48col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Description
and alternative to && operator
\end_layout

\begin_layout Description
and_eq alternative to &= operator
\end_layout

\begin_layout Description
asm insert an assembly instruction
\end_layout

\begin_layout Description
auto declare a local variable, or we can let the compiler to deduce the
 type of the variable from the initialization.
\end_layout

\begin_layout Description
bitand alternative to bitwise & operator
\end_layout

\begin_layout Description
bitor alternative to | operator
\end_layout

\begin_layout Description
bool declare a boolean variable
\end_layout

\begin_layout Description
break break out of a loop
\end_layout

\begin_layout Description
case a block of code in a switch statement
\end_layout

\begin_layout Description
catch handles exceptions from throw
\end_layout

\begin_layout Description
char declare a character variable
\end_layout

\begin_layout Description
class declare a class
\end_layout

\begin_layout Description
compl alternative to ~ operator
\end_layout

\begin_layout Description
const declare immutable data or functions that do not change data
\end_layout

\begin_layout Description
const_cast cast from const variables
\end_layout

\begin_layout Description
continue bypass iterations of a loop
\end_layout

\begin_layout Description
default default handler in a case statement
\end_layout

\begin_layout Description
#define All header files should have #define guards to prevent multiple
 inclusion.
\end_layout

\begin_layout Description
delete make dynamic memory available
\end_layout

\begin_layout Description
do looping construct
\end_layout

\begin_layout Description
double declare a double precision floating-point variable
\end_layout

\begin_layout Description
dynamic_cast perform runtime casts
\end_layout

\begin_layout Description
else alternate case for an if statement
\end_layout

\begin_layout Description
enum create enumeration types
\end_layout

\begin_layout Description
exit() ending a process
\end_layout

\begin_layout Description
explicit only use constructors when they exactly match
\end_layout

\begin_layout Description
export allows template definitions to be separated from their declarations
\end_layout

\begin_layout Description
extern declares a variable or function and specifies that it has external
 linkage
\end_layout

\begin_layout Description
extern
\begin_inset space ~
\end_inset

"C" enables C function call from C++ by forcing C-linkage
\end_layout

\begin_layout Description
false a constant representing the boolean false value
\end_layout

\begin_layout Description
float declare a floating-point variable
\end_layout

\begin_layout Description
for looping construct
\end_layout

\begin_layout Description
friend grant non-member function access to private data
\end_layout

\begin_layout Description
goto jump to a different part of the program
\end_layout

\begin_layout Description
if execute code based on the result of a test
\end_layout

\begin_layout Description
inline optimize calls to short functions
\end_layout

\begin_layout Description
int declare an integer variable
\end_layout

\begin_layout Description
long declare a long integer variable
\end_layout

\begin_layout Description
mutable override a const variable
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Description
namespace partition the global namespace by defining a scope
\end_layout

\begin_layout Description
new allocate dynamic memory for a new variable
\end_layout

\begin_layout Description
not alternative to ! operator
\end_layout

\begin_layout Description
not_eq alternative to != operator
\end_layout

\begin_layout Description
operator create overloaded operator functions
\end_layout

\begin_layout Description
or alternative to || operator
\end_layout

\begin_layout Description
or_eq alternative to |= operator
\end_layout

\begin_layout Description
private declare private members of a class
\end_layout

\begin_layout Description
protected declare protected members of a class
\end_layout

\begin_layout Description
public declare public members of a class
\end_layout

\begin_layout Description
register request that a variable be optimized for speed
\end_layout

\begin_layout Description
reinterpret_cast change the type of a variable
\end_layout

\begin_layout Description
short declare a short integer variable
\end_layout

\begin_layout Description
signed modify variable type declarations
\end_layout

\begin_layout Description
sizeof return the size of a variable or type
\end_layout

\begin_layout Description
static create permanent storage for a variable
\end_layout

\begin_layout Description
static_cast perform a nonpolymorphic cast
\end_layout

\begin_layout Description
struct define a new structure
\end_layout

\begin_layout Description
switch execute code based on different possible values for a variable
\end_layout

\begin_layout Description
template create generic functions
\end_layout

\begin_layout Description
this a pointer to the current object
\end_layout

\begin_layout Description
throw throws an exception
\end_layout

\begin_layout Description
true a constant representing the boolean true value
\end_layout

\begin_layout Description
try execute code that can throw an exception
\end_layout

\begin_layout Description
typedef create a new type name from an existing type
\end_layout

\begin_layout Description
typeid describes an object
\end_layout

\begin_layout Description
typename declare a class or undefined type
\end_layout

\begin_layout Description
union a structure that assigns multiple variables to the same memory location
\end_layout

\begin_layout Description
unsigned declare an unsigned integer variable
\end_layout

\begin_layout Description
using import complete or partial namespaces into the current scope
\end_layout

\begin_layout Description
virtual create a function that can be overridden by a derived class
\end_layout

\begin_layout Description
void declare functions or data with no associated data type
\end_layout

\begin_layout Description
volatile warn the compiler about variables that can be modified unexpectedly
\end_layout

\begin_layout Description
void declare functions or data with no associated data type
\end_layout

\begin_layout Description
wchar_t declare a wide-character variable
\end_layout

\begin_layout Description
while looping construct
\end_layout

\begin_layout Description
xor alternative to ^ operator
\end_layout

\begin_layout Description
xor_eq alternative to ^= operator
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand lstlistoflistings

\end_inset


\end_layout

\end_body
\end_document
